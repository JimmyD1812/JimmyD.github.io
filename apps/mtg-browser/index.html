<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTG Collection Browser</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="icon" href="data:,">
<script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.min.js"></script>
<style>
  /* ===== Theme ===== */
  :root{
    --bg:#0b0d0f; --bg-2:#0f1317; --panel:#12161a; --muted:#9aa4ad; --text:#e8edf2;
    --accent:#6ee7ff; --accent-2:#a78bfa; --danger:#ff7d7d; --card:#171c22; --chip:#1b222a; --border:#24303a;
    --btn-fs:14px; --btn-lh:1.15; --btn-fw:600;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial}
  body{
    min-height:100vh;min-height:100dvh;
    background:
      radial-gradient(1200px 600px at 70% -10%, #1b24311f, transparent),
      radial-gradient(1000px 600px at -10% 110%, #1b24311a, transparent),
      repeating-linear-gradient(90deg, #ffffff06 0 1px, #0000 1px 20px),
      repeating-linear-gradient(0deg,  #ffffff06 0 1px, #0000 1px 20px),
      var(--bg);
    background-attachment:fixed,fixed,fixed,fixed,fixed;
  }
  *{box-sizing:border-box}
  a{color:var(--accent)}
  .wrap{max-width:1200px;margin:0 auto;padding:20px}
  header{display:flex;align-items:center;gap:14px;flex-wrap:wrap;margin-bottom:16px}
  header .title{
    font-weight:900; letter-spacing:.3px; font-size:24px; line-height:1.1;
    background:linear-gradient(90deg,var(--accent),var(--accent-2));
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 0 18px #6ee7ff22;
  }
  .bar{display:flex;gap:10px;flex-wrap:wrap}
  .btn, a.btn, label.btn{
    position:relative;
    background:linear-gradient(var(--panel),var(--panel)) padding-box,
               linear-gradient(120deg,var(--border),#2d3a46) border-box;
    border:1px solid transparent; color:var(--text); padding:10px 14px; border-radius:12px;
    cursor:pointer; text-decoration:none;
    transition:transform .15s ease, box-shadow .2s ease, border-color .2s ease;
    display:inline-flex; align-items:center; gap:10px;
    font-size:var(--btn-fs); line-height:var(--btn-lh); font-weight:var(--btn-fw);
  }
  .btn:hover{ border-image:linear-gradient(120deg,var(--accent),var(--accent-2)) 1;
    box-shadow:0 0 0 3px #6ee7ff1a,0 6px 18px #0008; transform:translateY(-1px) }
  .btn.danger:hover{ border-image:linear-gradient(120deg,#ff7d7d,#ffb3b3) 1 }
  .ghost{background:transparent}
  .file{position:relative;overflow:hidden}
  .file input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer}

  /* Layout */
  .grid{display:grid;grid-template-columns:320px 1fr;gap:16px;align-items:start}
  @media (max-width:900px){
    .grid{grid-template-columns:1fr}
    .details{position:sticky;top:12px;z-index:30}
  }

  /* Panels */
  .panel{ position:relative;
    background:linear-gradient(var(--panel),var(--panel)) padding-box,
               linear-gradient(135deg,#22303b,#161d22,#22303b) border-box;
    border:1px solid transparent; border-radius:16px; box-shadow:0 8px 24px #0008;
  }
  .panel .head{ padding:14px 16px; border-bottom:1px solid var(--border);
    display:flex;align-items:center;justify-content:space-between;gap:12px }
  .panel .body{ padding:14px 16px }
  .muted{color:var(--muted)} .small{font-size:12px} .muted.small{opacity:.9}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center} .grow{flex:1 1 auto}

  /* Inputs */
  :root { color-scheme:dark }
  input[type=text],select{
    background:linear-gradient(var(--card),var(--card)) padding-box,
               linear-gradient(120deg,#2b3946,#1d252d) border-box;
    color:var(--text); border:1px solid transparent; border-radius:12px;
    padding:10px 12px; width:100%; transition:box-shadow .2s ease,border-image .2s ease;
  }
  input[type=text]::placeholder{color:#9aa4adcc}
  input[type=text]:focus,select:focus{ outline:none; border-image:linear-gradient(120deg,var(--accent),var(--accent-2)) 1; box-shadow:0 0 0 3px #6ee7ff2a }

  /* Chips */
  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{ display:inline-flex;align-items:center;gap:8px;background:var(--chip);
    border:1px solid var(--border); padding:6px 10px; border-radius:999px; font-size:12px }
  .chip, .stat { white-space:nowrap }
  label.chip input{accent-color:var(--accent)}
  label.chip:has(input:checked){
    background:linear-gradient(90deg,#1c2430,#1d2732) padding-box,
               linear-gradient(90deg,var(--accent),var(--accent-2)) border-box;
    border:1px solid transparent; box-shadow:0 0 0 3px #6ee7ff22; transform:translateY(-1px)
  }

  /* Results */
  .results{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
  .card{
    background:linear-gradient(var(--card),var(--card)) padding-box,
               linear-gradient(145deg,#22313e,#161e24) border-box;
    border:1px solid transparent;border-radius:14px;overflow:hidden;display:flex;flex-direction:column;
    transition:transform .18s ease, box-shadow .25s ease, border-image .2s ease; isolation:isolate;
  }
  .card:hover{ transform:translateY(-3px); border-image:linear-gradient(145deg,var(--accent),var(--accent-2)) 1;
    box-shadow:0 14px 30px #000a, 0 0 0 4px #6ee7ff14 inset }
  .card img{ width:100%; aspect-ratio:3/4; object-fit:cover; display:block; background:#000; transform:scale(.95); transition:transform .25s ease, filter .25s ease; filter:saturate(1.02) contrast(1.02) }
  .card:hover img{ transform:scale(1.0) }
  .card .meta{padding:12px 12px 14px;display:flex;flex-direction:column;gap:8px}
  .card .line{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .qty{display:flex;align-items:center;gap:6px}
  .qty .btn.ghost{border-color:#2b3946}
  .qty input{width:56px;text-align:center;background:#0d1117;border:1px solid #2a3742;border-radius:10px;color:var(--text);padding:6px}
  .stat{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;
    background:linear-gradient(#202a33,#1a232b) padding-box, linear-gradient(90deg,#2d3a46,#24303a) border-box;
    border:1px solid transparent;border-radius:999px;font-size:12px}
  .inline-msg{font-size:12px;color:var(--muted)}
  .err{color:#ffb3b3}
  #status{ background:linear-gradient(#1a222a,#1a222a) padding-box,
           linear-gradient(90deg,#2e3b47,#24303a) border-box; border:1px solid transparent;
           border-radius:999px; padding:4px 10px }

  /* Commander popover ABOVE the button */
  .combo-wrap{ position:relative; display:inline-block; }
  .combo-chip.btn{
    background:linear-gradient(90deg,var(--accent),var(--accent-2)) padding-box,
               linear-gradient(120deg,var(--border),#2d3a46) border-box;
    border:1px solid transparent; color:#0b0d0f; font-weight:800; text-shadow:0 1px 0 #ffffff60;
  }
  .combo-chip.btn:hover{ box-shadow:0 0 0 4px #6ee7ff2a, 0 10px 24px #0008; transform:translateY(-1px) }
  .combo-pop{
    position:absolute; bottom: calc(100% + 8px); right:0; /* ABOVE */
    background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:10px;
    min-width:240px; max-width:520px; box-shadow:0 16px 40px #000a; z-index:1000; display:none;
  }
  .combo-wrap.open .combo-pop{ display:block }

  /* Toggle switch */
  .switch{ display:inline-flex; align-items:center; gap:8px; user-select:none }
  .switch .toggle{ width:44px;height:24px;border-radius:999px;background:#1a222a;border:1px solid var(--border);position:relative;transition:background .2s,border-color .2s,box-shadow .2s }
  .switch .toggle::after{ content:"";position:absolute;top:2px;left:2px;width:20px;height:20px;border-radius:50%;background:#c6d3de;transition:transform .2s,background .2s; box-shadow:0 1px 2px #0008 }
  .switch input{ position:absolute;opacity:0;pointer-events:none }
  .switch input:checked + .toggle{ background:linear-gradient(90deg,var(--accent),var(--accent-2)); border-color:transparent; box-shadow:0 0 0 3px #6ee7ff22 }
  .switch input:checked + .toggle::after{ transform:translateX(20px); background:#0b0d0f }
  .switch .label{ font-size:12px; color:var(--muted) }

  /* Details collapsible (mobile) */
  .details .body{ overflow:hidden; max-height:1000px; opacity:1; transform:translateY(0); transform-origin:top;
    transition:max-height 220ms ease, opacity 180ms ease, transform 220ms ease }
  .details.collapsed .body{ max-height:0; opacity:0; transform:translateY(-6px); pointer-events:none }
  .details.collapsed .head{ border-bottom:none; border-radius:14px; box-shadow:0 8px 24px #0008; background:var(--panel) }
  .details .head strong::after{ content:' — tap to expand'; font-weight:500;color:var(--muted);margin-left:6px;font-size:12px }
  .details:not(.collapsed) .head strong::after{ content:'' }

  /* Deck sidebar */
  .deck-toggle{ margin-left:auto }
  #deckPanel{
    position:fixed; top:0; right:-420px; width:420px; height:100dvh; z-index:3000;
    background:var(--panel); border-left:1px solid var(--border); box-shadow:-10px 0 30px #000a;
    transition:right .25s ease; display:flex; flex-direction:column;
  }
  #deckPanel.open{ right:0 }
  #deckHead{ padding:14px 16px; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:8px }
  #deckBody{ padding:12px 14px; overflow:auto }
  .pill{ display:inline-flex; align-items:center; gap:6px; background:#1a2027; border:1px solid #27333f; padding:4px 10px; border-radius:999px; font-size:12px }
  .sec{ margin:10px 0 14px }
  .sec h4{ margin:6px 0 8px; font-size:13px; color:var(--muted); font-weight:700; text-transform:uppercase; letter-spacing:.04em }
  /* Two-line layout for deck rows */
.deck-row{
  display:flex;
  flex-direction:column;          /* stack title then controls */
  align-items:flex-start;         /* left align */
  gap:6px;
  padding:10px 0;
  border-bottom:1px dashed #2b3742;
}

/* First line: qty + name */
.deck-title{
  display:flex; align-items:center; gap:10px;
  font-weight:600;
}

/* Second line: availability + buttons (wrap nicely on mobile) */
.deck-controls{
  display:flex; align-items:center; gap:8px; flex-wrap:wrap;
  font-size:12px;
}

.deck-qtypill{
  display:inline-flex; align-items:center; justify-content:center;
  min-width:28px; padding:2px 6px; border-radius:999px;
  background:#1b222a; border:1px solid var(--border);
}

/* make the tiny availability label subtle */
.deck-avail{ color:var(--muted); margin-right:4px; }

  .deck-row:last-child{ border-bottom:none }
  .slot{ display:flex; align-items:center; gap:8px; min-width:0 }
  .slot strong{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px }
  .tiny{ font-size:11px; color:#8aa0b6 }
  .kpi{ display:flex; gap:8px; flex-wrap:wrap }
  progress{ width:100%; height:12px; accent-color:var(--accent) }
  progress::-webkit-progress-bar{ background:#0f1419;border-radius:999px }
  progress::-webkit-progress-value{ background:linear-gradient(90deg,var(--accent),var(--accent-2)); border-radius:999px }
  .badge{ border:1px solid #2b3946; border-radius:8px; padding:2px 6px; font-size:11px; color:#a9bacb }

  .mini-btn{ background:#192028; border:1px solid #2a3742; padding:4px 8px; border-radius:8px; font-size:12px; cursor:pointer }
  .mini-btn:hover{ border-color:#6ee7ff }

  .droptarget{ border:1px dashed #2a3742; border-radius:10px; padding:6px 8px }
  .droptarget.drag{ border-color:var(--accent); box-shadow:0 0 0 3px #6ee7ff22 inset }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">🧰 MTG Collection Browser</div>
      <div class="muted">Local-first • Works offline • Zero backend</div>
      <button class="btn deck-toggle" id="btnDeck">🧩 Deck Mode</button>
    </header>

    <div class="bar" style="margin-bottom:12px">
      <button class="btn" id="btnUpdateDB" title="Force reindex now (Alt-click for full rebuild)">Update database</button>
      <button class="btn" id="btnExport">⬇️ Export Collection (JSON)</button>

      <label class="btn file">⬆️ Import Collection (JSON)
        <input id="importCollection" type="file" accept=".json" />
      </label>

      <label class="btn file">📄 Add Cards (CSV)
        <input id="importCSV" type="file" accept=".csv" />
      </label>

      <label class="btn file">📝 Add Cards (TXT)
        <input id="importTXT" type="file" accept=".txt" />
      </label>

      <!-- Put the “clear” buttons onto the next line -->
      <div style="flex-basis:100%"></div>

      <button class="btn danger" id="btnClearDB" title="Delete all cards from the local database">🗑️ Clear Card DB</button>
      <button class="btn danger" id="btnClearCollection" title="Clear only your collection quantities">🧹 Clear Collection</button>

      <div class="muted small">Tip: Best results from <span class="kbd">MTG Scanner — Dragon Shield</span> CSV export or <span class="kbd">TCGplayer Scanner</span> TXT share file.</div>
    </div>

    <div class="grid">
      <section class="panel details">
        <div class="head"><strong>Search</strong></div>
        <div class="body">
          <div class="row" style="margin-bottom:8px">
            <input id="qName" type="text" placeholder="Name contains… (supports ^prefix and suffix$)" />
          </div>
          <div class="row" style="margin-bottom:8px">
            <input id="qText" type="text" placeholder="Oracle text contains… (e.g., double strike)" />
          </div>
          <div class="row" style="margin-bottom:8px">
            <select id="qType">
              <option value="">Any Type</option>
              <option>Creature</option><option>Instant</option><option>Sorcery</option>
              <option>Artifact</option><option>Enchantment</option><option>Planeswalker</option><option>Land</option>
            </select>
            <select id="qRarity">
              <option value="">Any Rarity</option>
              <option>common</option><option>uncommon</option><option>rare</option><option>mythic</option>
            </select>
            <input id="qSubtype" type="text" placeholder="Subtype (e.g., Sliver)" />
          </div>

          <div class="row" style="margin-bottom:8px">
            <div class="chips">
              <label class="chip"><input type="checkbox" class="ci" value="W"> White</label>
              <label class="chip"><input type="checkbox" class="ci" value="U"> Blue</label>
              <label class="chip"><input type="checkbox" class="ci" value="B"> Black</label>
              <label class="chip"><input type="checkbox" class="ci" value="R"> Red</label>
              <label class="chip"><input type="checkbox" class="ci" value="G"> Green</label>
              <label class="chip"><input type="checkbox" class="ci" value="C"> Colorless</label>
            </div>

            <select id="colorMode" title="How to match colors">
              <option value="include">Include selected colors</option>
              <option value="exact">Exactly selected colors</option>
            </select>

            <div class="row" style="gap:10px; align-items:center">
              <label class="switch">
                <input type="checkbox" id="filterCommander" />
                <span class="toggle" aria-hidden="true"></span>
                <span class="label">Potential Commander</span>
              </label>
              <button class="btn" id="btnSearch">Search</button>
            </div>
          </div>

          <div class="muted small" id="dbStats">DB: — cards • Collection: — entries</div>
        </div>
      </section>

      <section class="panel">
        <div class="head">
          <strong>Results</strong>
          <div class="muted small" id="status">Ready.</div>
        </div>
        <div class="body">
          <div id="importBox" class="muted small" style="display:none; margin-bottom:12px">
            <div>Importing… <progress id="importProgress" max="100" value="0"></progress></div>
            <div id="importNote" class="muted small"></div>
          </div>

          <div id="csvBox" class="muted small" style="display:none; margin-bottom:12px">
            <div>Importing CSV… <progress id="csvProgress" max="100" value="0"></progress></div>
            <div id="csvNote" class="muted small"></div>
          </div>

          <div id="resolveBox" class="panel" style="display:none; margin-bottom:12px">
            <div class="head">
              <strong>Resolve Unmatched Import Rows</strong>
              <div class="row" style="gap:8px;align-items:center">
                <div class="muted small" id="resolveStats">0 unresolved</div>
                <button class="btn" id="resolveClear" title="Hide this panel">Clear All</button>
              </div>
            </div>
            <div class="body">
              <div class="muted small" style="margin-bottom:8px">
                If a printing exists on <strong>PLST — The List</strong>, we auto-select it and don’t show a row.
              </div>
              <div id="resolveList" class="small"></div>
            </div>
          </div>

          <div id="results" class="results"></div>
        </div>
      </section>
    </div>
  </div>

  <!-- ===== Deck Sidebar ===== -->
  <aside id="deckPanel" aria-label="Deck Mode">
    <div id="deckHead">
      <strong>Deck Mode</strong>
      <span class="badge" id="deckStatus">Commander • 0/100</span>
      <div class="grow"></div>
      <button class="btn ghost" id="btnCloseDeck">✕</button>
    </div>
    <div id="deckBody">
      <div class="sec">
        <h4>Format</h4>
        <div class="row">
          <select id="deckFormat">
            <option value="commander">Commander (EDH)</option>
            <option value="sixty">60-card</option>
          </select>
          <label class="switch">
            <input type="checkbox" id="deckSingleton" checked />
            <span class="toggle"></span><span class="label">Singleton (EDH rule)</span>
          </label>
          <label class="switch" title="Only show/add cards that fit your commander's color identity">
            <input type="checkbox" id="deckColorLock" checked />
            <span class="toggle"></span><span class="label">Color identity lock</span>
          </label>
          <label class="switch" title="Ignore ownership limits">
            <input type="checkbox" id="deckProxies" />
            <span class="toggle"></span><span class="label">Allow proxies</span>
          </label>
        </div>
        <div class="row tiny" id="deckLegalMsg" style="margin-top:6px;color:#ffb3b3;display:none"></div>
      </div>

      <div class="sec" id="commanderSec">
        <h4>Commander</h4>
        <div class="row">
          <div class="pill" id="cmdrPrimary">None</div>
          <button class="mini-btn" id="btnClearCmdr">Clear</button>
        </div>
        <div class="tiny" style="margin-top:6px">Tip: In results, use the card menu to “Set as Commander”.</div>
      </div>

      <div class="sec">
        <h4>Progress</h4>
        <div class="row kpi">
          <div class="pill">Deck size: <span id="kDeckSize">0</span>/<span id="kDeckTarget">100</span></div>
          <div class="pill">Creatures: <span id="kCreatures">0</span></div>
          <div class="pill">Noncreatures: <span id="kNoncreatures">0</span></div>
          <div class="pill">Lands: <span id="kLands">0</span></div>
        </div>
        <progress id="deckProg" max="100" value="0" style="margin-top:8px"></progress>
      </div>

      <div class="sec">
        <h4>Deck List (drag cards here)</h4>
        <div id="deckDrop" class="droptarget">
          <div id="deckList"></div>
        </div>
        <div class="row" style="margin-top:8px">
          <button class="mini-btn" id="btnSaveDeck">💾 Save</button>
          <button class="mini-btn" id="btnNewDeck">✨ New</button>
          <select id="savedDecks"></select>
          <button class="mini-btn" id="btnLoadDeck">Open</button>
          <button class="mini-btn" id="btnDeleteDeck">Delete</button>
        </div>
      </div>

      <div class="sec">
        <h4>Stats</h4>
        <div class="row kpi">
          <div class="pill">Avg CMC: <span id="sAvgCmc">0.0</span></div>
          <div class="pill">Pips W/U/B/R/G: <span id="sPips">0/0/0/0/0</span></div>
        </div>
        <div class="tiny" style="margin-top:6px">Curve: <span id="sCurveTxt">—</span></div>
      </div>

      <div class="sec">
        <h4>Land Helper</h4>
        <div class="row">
          <input id="landCount" type="text" value="36" style="width:80px"/>
          <button class="mini-btn" id="btnSuggestLands">Suggest split</button>
          <div class="tiny" id="landSuggest" style="margin-left:8px"></div>
        </div>
      </div>

      <div class="sec">
        <h4>Packages</h4>
        <div class="row" id="pkgRow">
          <button class="mini-btn" data-pkg="ramp">Ramp (8–10)</button>
          <button class="mini-btn" data-pkg="draw">Card Draw (8+)</button>
          <button class="mini-btn" data-pkg="removal">Removal (6–8)</button>
          <button class="mini-btn" data-pkg="wipes">Board Wipes (2–3)</button>
        </div>
        <div class="tiny" id="pkgNote" style="margin-top:6px"></div>
      </div>

      <div class="sec">
        <h4>Suggestions (from your collection)</h4>
        <div id="suggestions" class="small">Pick a commander to see synergy.</div>
      </div>

      <div class="sec">
        <h4>Cuts Helper</h4>
        <div id="cuts" class="small">Add more cards to see easy trims.</div>
      </div>

      <div class="sec">
        <h4>Export</h4>
        <div class="row">
          <button class="mini-btn" id="expText">Plain text</button>
          <button class="mini-btn" id="expMtgo">MTGO</button>
          <button class="mini-btn" id="expMox">Moxfield string</button>
        </div>
        <div class="tiny" id="expOut" style="margin-top:6px"></div>
      </div>
    </div>
  </aside>

<script>
/* =================== Dexie (DB) =================== */
const db = new Dexie('mtgDB');
db.version(2).stores({
  cards: 'id, name, name_lc, rarity, set, set_name, type_lc, subtype_lc, *color_identity, collector_number',
  collection: 'id, qty',
  decks: '++id, name, updated_at'
});

/* =================== Refs & Globals =================== */
const els = {
  btnUpdateDB: $('#btnUpdateDB'), btnExport: $('#btnExport'),
  importCollection: $('#importCollection'), importCSV: $('#importCSV'), importTXT: $('#importTXT'),
  csvBox: $('#csvBox'), csvProgress: $('#csvProgress'), csvNote: $('#csvNote'),
  importBox: $('#importBox'), importProgress: $('#importProgress'), importNote: $('#importNote'),
  btnClearDB: $('#btnClearDB'), btnClearCollection: $('#btnClearCollection'),
  resolveBox: $('#resolveBox'), resolveList: $('#resolveList'), resolveStats: $('#resolveStats'), resolveClear: $('#resolveClear'),
  results: $('#results'), status: $('#status'), dbStats: $('#dbStats'),

  qName: $('#qName'), qText: $('#qText'), qType: $('#qType'), qSubtype: $('#qSubtype'), qRarity: $('#qRarity'),
  btnSearch: $('#btnSearch'), filterCommander: $('#filterCommander'), colorMode: $('#colorMode'),

  searchPanel: $('section.panel.details'), searchHead: document.querySelector('section.panel.details .head'),

  // Deck UI
  btnDeck: $('#btnDeck'), deckPanel: $('#deckPanel'), btnCloseDeck: $('#btnCloseDeck'),
  deckFormat: $('#deckFormat'), deckSingleton: $('#deckSingleton'), deckColorLock: $('#deckColorLock'), deckProxies: $('#deckProxies'),
  deckStatus: $('#deckStatus'), kDeckSize: $('#kDeckSize'), kDeckTarget: $('#kDeckTarget'),
  kCreatures: $('#kCreatures'), kNoncreatures: $('#kNoncreatures'), kLands: $('#kLands'), deckProg: $('#deckProg'),
  commanderSec: $('#commanderSec'), cmdrPrimary: $('#cmdrPrimary'), btnClearCmdr: $('#btnClearCmdr'),
  deckDrop: $('#deckDrop'), deckList: $('#deckList'), deckLegalMsg: $('#deckLegalMsg'),
  btnSaveDeck: $('#btnSaveDeck'), btnNewDeck: $('#btnNewDeck'), savedDecks: $('#savedDecks'), btnLoadDeck: $('#btnLoadDeck'), btnDeleteDeck: $('#btnDeleteDeck'),
  sAvgCmc: $('#sAvgCmc'), sPips: $('#sPips'), sCurveTxt: $('#sCurveTxt'),
  landCount: $('#landCount'), landSuggest: $('#landSuggest'), btnSuggestLands: $('#btnSuggestLands'),
  pkgRow: $('#pkgRow'), pkgNote: $('#pkgNote'),
  suggestions: $('#suggestions'), cuts: $('#cuts'),
  expText: $('#expText'), expMtgo: $('#expMtgo'), expMox: $('#expMox'), expOut: $('#expOut'),
};

// tiny $ helper
function $(sel){ return document.querySelector(sel); }
function $all(sel){ return Array.from(document.querySelectorAll(sel)); }
const fmt = (n)=> (typeof n==='number'? n.toLocaleString() : n);
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
const MOBILE_BP = 900, COLLAPSE_THRESHOLD = 250;
let suppressAutoUntil=0;

/* =================== Commander/Front-face helper =================== */
function isPotentialCommanderFront(card){
  const front = (Array.isArray(card.faces)&&card.faces.length)? card.faces[0] : null;
  const frontTL = (front?.type_line || card.type_line || '');
  const frontOT = (front?.oracle_text || '').toLowerCase();
  const isLegendaryCreature = /\blegendary\b.*\bcreature\b/i.test(frontTL);
  const isLegendaryVehicle  = /\blegendary\b.*\bvehicle\b/i.test(frontTL);
  const saysCommander = /can be your commander/i.test(frontOT);
  return isLegendaryCreature || isLegendaryVehicle || saysCommander;
}

function deckRowHTML(item){
  // item: { id, name, qty, avail } — adapt to your object shape
  return `
    <div class="deck-row" data-id="${item.id}">
      <div class="deck-title">
        <span class="deck-qtypill">${item.qty}×</span>
        <span class="deck-name">${item.name}</span>
      </div>

      <div class="deck-controls">
        <span class="deck-avail">avail ${item.avail ?? 0}</span>
        <button class="btn ghost" onclick="deckAdjust('${item.id}', -1)">−</button>
        <button class="btn ghost" onclick="deckAdjust('${item.id}', 1)">＋</button>
        <button class="btn" onclick="deckRemove('${item.id}')">Remove</button>
      </div>
    </div>
  `;
}
  
/* =================== Color labels =================== */
function getColorLabel(ci){
  const set = new Set(ci||[]);
  const s = [...set].sort().join('');
  const mono = {W:'White',U:'Blue',B:'Black',R:'Red',G:'Green','':'Colorless'};
  if (s.length<=1) return mono[s] || 'Colorless';

  // Two-color guilds
  const guilds = {
    UW:'Azorius', WR:'Boros', UB:'Dimir',
    BG:'Golgari', GR:'Gruul', UR:'Izzet',
    WB:'Orzhov', BR:'Rakdos', GW:'Selesnya',
    UG:'Simic'
  };
  if (guilds[s]) return guilds[s];

  // Three-color shards/wedges
  const tri = {
    BGU:'Sultai: Black/Blue/Green', GRW:'Naya: Green/Red/White', BRW:'Mardu: Black/Red/White',
    BGW:'Abzan: Black/Green/White', URW:'Jeskai: Blue/Red/White',
    BGR:'Jund: Black/Green/Red', BRU:'Grixis: Black/Blue/Red', GUW:'Bant: Blue/Green/White',
    GRU:'Temur: Blue/Green/Red', BRU:'Grixis: Black/Blue/Red'
  };
  // normalize sorted combos to keys above (sorted alphabetical)
  const sort3 = {BGR:'BGR',BRU:'BRU',BGU:'BGU',GUW:'GUW',GRW:'GRW',BRW:'BRW',BGW:'BGW',URW:'URW',GRU:'GRU'};
  if (s.length===3){
    const key = sort3[s] || s;
    for (const k in tri){ if ([...k].sort().join('')===s) return tri[k]; }
  }

  // Four-color nicknames
  const four = {
    BRGW:'Dune: WBRG (No Blue)', BRGU:'Glint: UBRG (No White)', GRUW:'Ink: WURG (No Black)',
    BGUW:'Witch: WUBG (No Red)', BRUW:'Yore: WUBR (No Green)'
  };
  if (s.length===4){
    for (const k in four){ if ([...k].sort().join('')===s) return four[k]; }
  }

  if (s.length===5) return 'WUBRG';
  return s.split('').join('/'); // fallback
}

/* =================== Normalize + Import =================== */
function sameBaseCardName(a,b){
  const norm = (s)=> (s||'').toLowerCase().replace(/^\s*a-\s*/,'').replace(/\s+/g,' ').trim();
  return norm(a)===norm(b);
}
function normalizeCard(raw){
  const faces = Array.isArray(raw.card_faces)? raw.card_faces.map(f=>({
    name: f.name||'', mana_cost:f.mana_cost||'', type_line:f.type_line||'', oracle_text:f.oracle_text||'',
    colors:f.colors||[], power:f.power??null, toughness:f.toughness??null, loyalty:f.loyalty??null,
    image:f.image_uris?.normal||null
  })) : null;
  const img = raw.image_uris?.normal || faces?.[0]?.image || null;
  const oracle_text = raw.oracle_text || (faces?.map(f=>f.oracle_text).filter(Boolean).join('\n')) || '';
  const mana_cost = raw.mana_cost || (faces?.map(f=>f.mana_cost).filter(Boolean).join(' // ')) || '';
  const type_line = raw.type_line || (faces?.map(f=>f.type_line).join(' // ')) || '';
  const combo_refs = (raw.all_parts||[])
    .filter(p=>p.component==='combo_piece')
    .filter(p=>p.id!==raw.id)
    .filter(p=>!sameBaseCardName(p.name, raw.name))
    .map(p=>({id:p.id,name:p.name||'',type_line:p.type_line||''}));

  const subtype = (type_line.split('—')[1]||'').trim();
  return {
    id: raw.id, oracle_id: raw.oracle_id||'', layout: raw.layout||'',
    name: raw.name, name_lc: raw.name.toLowerCase(), set: raw.set, set_name: raw.set_name||'', rarity: raw.rarity||'',
    image: img, oracle_text, mana_cost, cmc: raw.cmc??null, type_line,
    type_lc: type_line.toLowerCase(), subtype_lc: subtype.toLowerCase(),
    colors: raw.colors||[], color_identity: raw.color_identity||[],
    power: raw.power ?? faces?.[0]?.power ?? null, toughness: raw.toughness ?? faces?.[0]?.toughness ?? null, loyalty: raw.loyalty ?? faces?.[0]?.loyalty ?? null,
    collector_number: raw.collector_number||'', purchase_uris: raw.purchase_uris||{}, scryfall_uri: raw.scryfall_uri||'', prices: raw.prices||{},
    faces, is_dfc: !!(faces&&faces.length>=2), all_parts: raw.all_parts||[], combo_refs
  };
}

const NDJSON_URL = (()=>{ const parts=location.pathname.split('/').filter(Boolean); const base = parts.length? `/${parts[0]}/` : '/'; return `${base}db/cards.ndjson.gz`; })();
function headKey(url){ return `ndjson_head::${url}`; }
async function getRemoteHead(url){
  const resp = await fetch(url,{method:'HEAD',cache:'no-store'});
  if(!resp.ok && resp.status!==304) throw new Error(`HEAD ${resp.status} ${resp.statusText}`);
  return { etag:resp.headers.get('etag')||'', last:resp.headers.get('last-modified')||'', len:resp.headers.get('content-length')||'' };
}
function saveHeadMeta(url,meta){ try{ localStorage.setItem(headKey(url), JSON.stringify(meta)); }catch{} }
function loadHeadMeta(url){ try{ return JSON.parse(localStorage.getItem(headKey(url)) || 'null'); }catch{ return null; } }
async function isRemoteUnchanged(url){
  const remote = await getRemoteHead(url); const prev = loadHeadMeta(url); if(!prev) return false;
  if (remote.etag&&prev.etag) return remote.etag===prev.etag;
  if (remote.last&&prev.last) return remote.last===prev.last;
  return false;
}
function gunzipStream(stream){
  if('DecompressionStream' in window) return stream.pipeThrough(new DecompressionStream('gzip'));
  if(!window.fflate) throw new Error('No gzip support');
  const reader = stream.getReader(); const gunzip = new fflate.AsyncGunzip();
  return new ReadableStream({
    start(controller){
      gunzip.ondata=(chunk,final)=>{ controller.enqueue(chunk); if(final) controller.close(); };
      gunzip.onerror=(err)=>controller.error(err);
      (async function pump(){ for(;;){ const {value,done}=await reader.read(); if(done){ gunzip.flush(); break; } gunzip.push(value); } })();
    },
    cancel(reason){ try{ reader.cancel(reason); }catch{} }
  });
}
async function importNDJSONFromURL(url=NDJSON_URL, {skipIfUnchanged=true}={}){
  show(els.importBox); els.importProgress.value=0; els.importNote.textContent=`Fetching ${url}…`;
  if(skipIfUnchanged){
    try{
      const skip = await isRemoteUnchanged(url); const count = await db.cards.count();
      if(skip && count>0){ els.importProgress.value=100; els.importNote.textContent='Remote file unchanged; skipped re-index.'; els.status.textContent='Remote unchanged; using existing DB'; hideStatusBars(); return; }
    }catch(e){ console.warn('HEAD failed; continue',e); }
  }
  let headMeta=null; try{ headMeta=await getRemoteHead(url); }catch{}
  const resp = await fetch(url,{cache:'no-store'}); if(!resp.ok) throw new Error(`Fetch failed: ${resp.status} ${resp.statusText}`);
  if(!resp.body) throw new Error('No response body stream');

  const ct=resp.headers.get('content-type')||'', enc=resp.headers.get('content-encoding')||'';
  const looksGzip = /\.gz($|\?)/i.test(url)||/gzip/i.test(ct)||/gzip/i.test(enc);
  let stream = resp.body; if(looksGzip) stream = gunzipStream(stream);
  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();

  const CHUNK=200; let leftover=''; let batch=[]; let inserted=0;
  els.status.textContent='Indexing remote cards…';

  for(;;){
    const {value,done}=await reader.read(); if(done) break;
    leftover += value;
    let nl; while((nl=leftover.indexOf('\n'))>=0){
      const line=leftover.slice(0,nl).trim(); leftover=leftover.slice(nl+1);
      if(!line) continue; try{ batch.push(normalizeCard(JSON.parse(line))); }catch{}
      if(batch.length>=CHUNK){ await db.cards.bulkPut(batch); inserted+=batch.length; batch.length=0;
        els.importProgress.value=Math.min(100, Math.round(inserted/5000*100));
        els.importNote.textContent=`Indexed ${inserted.toLocaleString()} cards…`; await new Promise(requestAnimationFrame);
      }
    }
  }
  if(leftover.trim()){ try{ batch.push(normalizeCard(JSON.parse(leftover.trim()))); }catch{} }
  if(batch.length){ await db.cards.bulkPut(batch); inserted+=batch.length; }
  els.importProgress.value=100; els.importNote.textContent=`Done. Indexed ${inserted.toLocaleString()} cards from URL.`;
  els.status.textContent='Remote import complete'; await refreshStats(); if(headMeta) saveHeadMeta(url, headMeta); hideStatusBars();
}
function hideStatusBars(delay=800){ setTimeout(()=>{ hide(els.importBox); hide(els.csvBox); }, delay); }

/* =================== Collection + Price helpers =================== */
function money(v){ const n=Number(v); return Number.isFinite(n)? `$${n.toFixed(2)}` : ''; }
function getUsdPrice(card, holo=false){ const p=card?.prices||{}; const v = holo ? (p.usd_foil ?? p.usd_etched) : p.usd; return money(v); }
function edhrecURL(card){ return `https://edhrec.com/cards/${slugifyForEdhrec(card.name)}`; }
function slugifyForEdhrec(s){ return s.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,''); }
function cardKingdomURL(card){ const name = encodeURIComponent(card.name), set=encodeURIComponent(card.set_name||''); return `https://www.cardkingdom.com/catalog/search?search=mtg_advanced&name=${name}&filter%5Bedition%5D=${set}`; }
function isDoubleFaced(card){ return (Array.isArray(card.faces)&&card.faces.length>=2) || ['transform','modal_dfc','meld','flip','double_faced_token'].includes(card.layout); }

/* =================== Results: render & interactions =================== */
const faceIndex = {}; // id -> face number
window.__cardsById = {};

function renderCardCard(card, qty=0, showComboBtn=false, inDeckQty=0){
  const colorLabel = getColorLabel(card.color_identity || []);
  const isDFC = isDoubleFaced(card);
  const f = card.faces?.[0];
  const ptText = (f?.power || f?.toughness) ? `${f.power ?? ''}/${f.toughness ?? ''}` : (f?.loyalty ? `Loyalty ${f.loyalty}` : '');
  const mcText = f?.mana_cost || card.mana_cost || '';
  const avail = Math.max(0, (qty||0) - (inDeckQty||0));

  const comboMarkup = showComboBtn ? `
    <div class="combo-wrap">
      <button class="btn combo-chip" title="Show related cards"
        onclick="showComboPopover('${card.id}', this)"
        onmouseenter="loadComboPieces('${card.id}')"
        ontouchstart="loadComboPieces('${card.id}')">✨ Related Cards</button>
      <div class="combo-pop" id="combo-pop-${card.id}" data-loaded="0">
        <div class="muted small">Loading…</div>
      </div>
    </div>` : '';

  return `
  <div class="card" draggable="true" ondragstart="dragCard(event,'${card.id}')">
    <img id="img-${card.id}" loading="lazy" alt="${card.name}" src="${(f?.image||card.image)||''}"
      onerror="this.src='';this.style.background='#0b0d0f'">
    <div class="meta">
      <div class="line">
        <strong id="title-${card.id}">${f?.name || card.name}</strong>
        <span class="chip">${colorLabel}</span>
      </div>

      <div class="line">
        ${card.rarity ? `<span class="chip">${card.rarity}</span>` : ''}
        <span class="badge" title="Owned remaining for deck">Avail: ${avail}</span>
      </div>

      <div class="line" style="gap:8px; flex-wrap:wrap">
        <button class="btn" onclick="addToDeck('${card.id}',1)" title="Add to current deck">Add to Deck</button>
        <button class="btn ghost" onclick="setCommander('${card.id}')" title="Set as Commander">Set Commander</button>
        ${comboMarkup}
      </div>

      <div class="row" style="justify-content:center; align-items:center; gap:10px; flex-wrap:wrap">
        <a class="btn" href="${card.scryfall_uri}" target="_blank">Scryfall</a>
        ${card.purchase_uris?.tcgplayer ? `<a class="btn" href="${card.purchase_uris.tcgplayer}" target="_blank">TCGplayer</a>` : ''}
        <a class="btn" href="${edhrecURL(card)}" target="_blank">EDHREC</a>
      </div>

      <div class="row" style="gap:10px; align-items:center">
        <div class="row" style="gap:6px; align-items:center">
          <span class="muted small">Price</span>
          <span class="stat" id="price-${card.id}">${getUsdPrice(card,false)||'—'}</span>
          <label class="chip" style="cursor:pointer">
            <input type="checkbox" id="holo-${card.id}" onchange="updateCardPrice('${card.id}')"> Holo
          </label>
        </div>
        ${isDFC ? `<button class="btn" onclick="flipCard('${card.id}')">Flip</button>` : ''}
      </div>
    </div>
  </div>`;
}

function flipCard(id){
  const card=window.__cardsById[id]; if(!card || !Array.isArray(card.faces) || card.faces.length<2) return;
  const i=(faceIndex[id]||0), next=(i+1)%card.faces.length; faceIndex[id]=next;
  const f=card.faces[next]; const img=$(`#img-${card.id}`); if(img) img.src = f.image || card.image || '';
  const nameEl=$(`#title-${card.id}`); if(nameEl) nameEl.textContent = f.name || card.name;
}

/* Related cards popover (above) */
window.showComboPopover = (cardId, btn)=>{
  const wrap = btn.closest('.combo-wrap'); if(!wrap) return;
  const was = wrap.classList.contains('open');
  document.querySelectorAll('.combo-wrap.open').forEach(w=>w.classList.remove('open'));
  if(!was){ wrap.classList.add('open'); loadComboPieces(cardId); }
};
document.addEventListener('click',(e)=>{ if(!e.target.closest('.combo-wrap')) document.querySelectorAll('.combo-wrap.open').forEach(w=>w.classList.remove('open')); });

window.loadComboPieces = async function(cardId){
  const base = window.__cardsById[cardId]; const pop=document.getElementById(`combo-pop-${cardId}`);
  if(!base||!pop||pop.dataset.loaded==='1') return;
  const refs=base.combo_refs||[]; if(!refs.length){ pop.innerHTML=`<div class="muted small">No related cards listed.</div>`; pop.dataset.loaded='1'; return; }

  const owned={}; (await db.collection.toArray()).forEach(r=>owned[r.id]=r.qty||0);
  const seen=new Set(); const tiles=[];
  for(const ref of refs){
    let rc=null; if(ref.id) rc = await db.cards.get(ref.id);
    if(!rc && ref.name){ const list=await db.cards.where('name_lc').equals(ref.name.toLowerCase()).toArray();
      rc=list.find(c=>c.oracle_id&&c.oracle_id!==base.oracle_id) || list[0] || null; }
    if(!rc) continue;
    if(rc.id===base.id) continue;
    if((rc.oracle_id&&base.oracle_id&&rc.oracle_id===base.oracle_id) || sameBaseCardName(base.name, rc.name)) continue;
    const key=rc.oracle_id||rc.id; if(seen.has(key)) continue; seen.add(key);
    const have=owned[rc.id]>0; const img=rc.image || rc.faces?.[0]?.image || '';
    tiles.push(`<a class="combo-item" href="${rc.scryfall_uri||'#'}" target="_blank" title="${rc.name}">
      ${have?`<div class="combo-owned">Owned ×${owned[rc.id]}</div>`:`<div class="combo-miss">Not owned</div>`}
      <img loading="lazy" src="${img}" alt="${rc.name}"></a>`);
  }
  pop.innerHTML = `<div class="combo-title">Related Cards</div><div class="combo-grid">${tiles.join('')||'<div class="muted small">No related cards found locally.</div>'}</div>`;
  pop.dataset.loaded='1';
};

/* =================== Search & Filters =================== */
function show(el){ el.style.display=''; } function hide(el){ el.style.display='none'; }
async function refreshStats(){ const cc=await db.cards.count(); const colc=await db.collection.count(); els.dbStats.textContent=`DB: ${fmt(cc)} cards • Collection: ${fmt(colc)} entries`; }

function colorsMatch(cardCI, selectedColors, mode='include'){
  if(!selectedColors || selectedColors.length===0) return true;
  const sel=new Set(selectedColors); const includeC=sel.has('C'); sel.delete('C');
  const ci=Array.isArray(cardCI)? cardCI : [];
  if(mode==='include'){
    if(ci.length===0) return includeC;
    if(sel.size===0) return false;
    for(const c of ci) if(!sel.has(c)) return false;
    return true;
  }else{ // exact
    if(includeC && sel.size>0) return false;
    if(includeC) return ci.length===0;
    if(ci.length!==sel.size) return false;
    for(const c of ci) if(!sel.has(c)) return false;
    return true;
  }
}

function matchCard(card, f){
  const name_lc=(card.name_lc||''), type_lc=(card.type_lc||''), subtype_lc=(card.subtype_lc||''), oracle_lc=(card.oracle_text||'').toLowerCase();

  if(f.name){
    const q=f.name;
    if(q.startsWith('^')){ if(!name_lc.startsWith(q.slice(1))) return false; }
    else if(q.endsWith('$')){ if(!name_lc.endsWith(q.slice(0,-1))) return false; }
    else{ const terms=q.split(/\s+/).filter(Boolean); for(const t of terms){ if(!name_lc.includes(t)) return false; } }
  }
  if(f.type && !type_lc.includes(f.type.toLowerCase())) return false;
  if(f.subtype && !subtype_lc.includes(f.subtype)) return false;
  if(f.rarity && card.rarity !== f.rarity) return false;
  if(f.text && !oracle_lc.includes(f.text)) return false;

  // Commander front-only
  if(f.commanderOnly && !isPotentialCommanderFront(card)) return false;

  // Commander color identity lock (from deck)
  if(f.ciLock && f.ciLock.length){
    // commander is colorless? allow only colorless
    if(f.ciLock.length===0){ if(card.color_identity.length!==0) return false; }
    else{
      // card CI must be subset of lock
      for(const c of card.color_identity) if(!f.ciLock.includes(c)) return false;
    }
  }

  if(!colorsMatch(card.color_identity, f.colors, f.colorMode||'include')) return false;
  return true;
}

async function buildLocalComboPresenceMap(cards){
  const refIdSet=new Set(); for(const card of cards){ for(const r of (card.combo_refs||[])) refIdSet.add(r.id); }
  if(!refIdSet.size) return new Map();
  const ids=[...refIdSet]; const rows=await db.cards.bulkGet(ids); const idToHit=new Map(ids.map((id,i)=>[id,rows[i]||null]));
  const result=new Map();
  for(const card of cards){
    const hasAny=(card.combo_refs||[]).some(r=>{
      const hit=idToHit.get(r.id); if(!hit) return false;
      if((hit.oracle_id&&card.oracle_id&&hit.oracle_id===card.oracle_id) || sameBaseCardName(card.name,hit.name)) return false;
      return true;
    });
    result.set(card.id,hasAny);
  }
  return result;
}

let latestOwnedMap = {}; // id -> qty (for availability)
async function search(){
  const filters={
    name: els.qName.value.trim().toLowerCase(),
    text: els.qText.value.trim().toLowerCase(),
    type: els.qType.value,
    subtype: els.qSubtype.value.trim().toLowerCase(),
    rarity: els.qRarity.value,
    colors: $all('.ci:checked').map(c=>c.value),
    colorMode: (els.colorMode && els.colorMode.value) || 'include',
    commanderOnly: !!(els.filterCommander && els.filterCommander.checked),
    ciLock: (deck.state.colorLock && deck.commander) ? (deck.commander.color_identity || []) : null
  };
  els.status.textContent='Searching your collection…';

  const owned = await db.collection.where('qty').above(0).toArray();
  latestOwnedMap = Object.fromEntries(owned.map(e=>[e.id, e.qty]));
  if(!owned.length){ els.results.innerHTML=''; els.status.textContent='Your collection is empty — import CSV to add cards.'; return; }
  const cards = await db.cards.bulkGet(owned.map(e=>e.id));

  const out=[]; const limit=200;
  for(const card of cards){ if(!card) continue; if(matchCard(card, filters)){ out.push(card); if(out.length>=limit) break; } }

  const comboPresence = await buildLocalComboPresenceMap(out);
  els.results.innerHTML = out.map(c=>{ window.__cardsById[c.id]=c;
    const showCombo=!!comboPresence.get(c.id);
    const inDeckQty = deck.entries.get(c.id)||0;
    return renderCardCard(c, latestOwnedMap[c.id]||0, showCombo, inDeckQty);
  }).join('');
  els.status.textContent=`${out.length} result(s).`;
}

/* =================== CSV/TXT import (unchanged mechanics) =================== */
/* (Kept your robust CSV/TXT handling with BOM/sep=, header peeling, resolver, etc.) */

function stripSepAndBOM(text){ if(!text) return text; if(text.charCodeAt(0)===0xFEFF) text=text.slice(1); const e=text.indexOf('\n'); const first=(e>=0?text.slice(0,e).trim():text.trim()); if(/^sep\s*=\s*./i.test(first)) text=e>=0?text.slice(e+1):''; return text; }
function parseCSV(text){ text=stripSepAndBOM(text); const rows=[]; let row=[],field='',inQ=false;
  for(let i=0;i<text.length;i++){ const c=text[i]; if(inQ){ if(c==='"'){ if(text[i+1]==='"'){ field+='"'; i++; }else inQ=false; } else field+=c; }
  else{ if(c==='"') inQ=true; else if(c===','){ row.push(field); field=''; } else if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; } else if(c!=='\r'){ field+=c; } } }
  row.push(field); if(row.length&&(row.length>1||row[0]!=='')) rows.push(row); return rows;
}
function parseScannerTXT(text){
  const out=[]; const lines=text.split(/\r?\n/);
  for(let i=0;i<lines.length;i++){
    const line=lines[i].trim(); if(!line) continue; if(/^total:/i.test(line)) continue; if(/^prices from/i.test(line)) continue;
    const m=line.match(/^\s*(\d+)\s+(.+?)(?:\s*\[(.*?)\])?(?:\s*\(.*?\))?\s*-\s*\$/); if(!m) continue;
    const qty=parseInt(m[1],10); let name=(m[2]||'').trim(); const bracket=(m[3]||'').trim(); if(/token/i.test(name)) continue; name=name.replace(/\s+/g,' ').trim();
    out.push({ row:i+1, name, qty:isFinite(qty)?qty:0, setCode:'', setName: bracket||'' });
  } return out;
}

const DEFAULT_TCGPLAYER_HEADER=["Folder Name","Quantity","Trade Quantity","Card Name","Set Code","Set Name","Card Number","Condition","Printing","Language","Price Bought","Date Bought","LOW","MID","MARKET"];
function peelCsvHeader(raw){ if(raw && raw.charCodeAt(0)===0xFEFF) raw=raw.slice(1); const nl1=raw.indexOf('\n'); const first=(nl1>=0?raw.slice(0,nl1):raw).trim();
  if(/^\s*"?\s*sep\s*=\s*,\s*"?\s*$/i.test(first)){ const start2=nl1>=0?nl1+1:raw.length; const nl2=raw.indexOf('\n',start2); const csvText=(nl2>=0?raw.slice(nl2+1):''); return {csvText, header:DEFAULT_TCGPLAYER_HEADER}; }
  if(/^Folder Name\b/i.test(first)){ const csvText=(nl1>=0?raw.slice(nl1+1):''); return {csvText, header:DEFAULT_TCGPLAYER_HEADER}; }
  return {csvText:raw, header:null};
}

function addManualCorrectionRow(wrap,item){
  const row=document.createElement('div'); row.className='row'; row.style.marginTop='8px';
  const msg=document.createElement('div'); msg.className='inline-msg'; msg.innerHTML=`<span class="err">Unmatched.</span> <span class="muted small">We couldn’t find this card in your local DB. If set options appear above, select one; otherwise update your database or verify the name, then re-import.</span>`;
  row.appendChild(msg); const spacer=document.createElement('div'); spacer.className='grow'; row.appendChild(spacer);
  const clearBtn=document.createElement('button'); clearBtn.className='btn ghost'; clearBtn.textContent='Clear';
  clearBtn.addEventListener('click',()=>{ item.resolved=true; updateResolveStats(); wrap.remove(); }); row.appendChild(clearBtn); wrap.appendChild(row);
}
let __unmatchedRows=[];
els.resolveClear.addEventListener('click',()=>{ hide(els.resolveBox); els.resolveList.innerHTML=''; els.resolveStats.textContent='0 unresolved'; __unmatchedRows=[]; });
function updateResolveStats(){ const remaining=__unmatchedRows.filter(x=>!x.resolved).length; els.resolveStats.textContent=`${remaining} unresolved`; if(!remaining){ setTimeout(()=>{ hide(els.resolveBox); els.resolveList.innerHTML=''; },200); } }
async function resolveOneUnmatched(item, chosenId){ const cur=await db.collection.get(chosenId)||{id:chosenId,qty:0}; cur.qty += (item.qty||0); await db.collection.put(cur); item.resolved=true; updateResolveStats(); await refreshStats(); search(); }

function selectCardByNameAndSet(candidates,setCode,setName,strict){
  if(candidates.length===1) return candidates[0];
  let card=null; if(setCode){ const sc=setCode.toLowerCase(); card=candidates.find(c=>(c.set||'').toLowerCase()===sc)||null; if(!card && strict) return null; }
  if(!card && setName){ const sn=setName.toLowerCase(); card=candidates.find(c=>(c.set_name||'').toLowerCase()===sn)||null; if(!card && strict && (setCode||setName)) return null; }
  if(!card) card=candidates[0]||null; return card;
}

async function renderResolveUnmatched(list){
  __unmatchedRows = list.map(x=>({...x, resolved:false}));
  if(!__unmatchedRows.length){ hide(els.resolveBox); els.resolveList.innerHTML=''; els.resolveStats.textContent='0 unresolved'; return; }
  show(els.resolveBox); els.resolveList.innerHTML=''; updateResolveStats();
  for(const item of __unmatchedRows){
    const nameLC=item.name.toLowerCase();
    let candidates=await db.cards.where('name_lc').equals(nameLC).toArray();
    if(!candidates.length) candidates=await db.cards.where('name_lc').startsWith(nameLC).toArray();
    if(!candidates.length){
      const wrap=document.createElement('div'); wrap.style.borderTop='1px solid var(--border)'; wrap.style.padding='10px 0';
      wrap.innerHTML = `<div><strong>${item.name}</strong> &nbsp;<span class="muted small">CSV set: ${item.setCode||'(none)'} ${item.setName? '— '+item.setName : ''}</span> • Qty: ${item.qty} • <span class="muted small">Row ${item.row}</span></div><div class="muted small" style="margin-top:6px">Card not recognized in local DB (or wrong name).</div>`;
      addManualCorrectionRow(wrap,item); els.resolveList.appendChild(wrap); continue;
    }
    const bySet=new Map();
    for(const c of candidates){ const key=(c.set||'').toUpperCase(); if(!bySet.has(key)) bySet.set(key,{set:key,set_name:c.set_name||'',any:c}); }
    if(bySet.has('PLST')){ const v=bySet.get('PLST'); await resolveOneUnmatched(item,v.any.id,v.set,v.set_name); continue; }
    const wrap=document.createElement('div'); wrap.style.borderTop='1px solid var(--border)'; wrap.style.padding='10px 0';
    const title=document.createElement('div'); title.innerHTML=`<strong>${item.name}</strong> &nbsp;<span class="muted small">CSV set: ${item.setCode||'(none)'} ${item.setName? '— '+item.setName : ''}</span> • Qty: ${item.qty} • <span class="muted small">Row ${item.row}</span>`; wrap.appendChild(title);
    const row=document.createElement('div'); row.style.marginTop='8px'; row.className='row';
    const prompt=document.createElement('div'); prompt.className='muted small'; prompt.textContent='Pick a set:'; row.appendChild(prompt);
    for(const v of bySet.values()){
      const btn=document.createElement('button'); btn.className='btn'; btn.textContent=`${v.set} — ${v.set_name||''}`;
      btn.addEventListener('click',async()=>{ await resolveOneUnmatched(item,v.any.id,v.set,v.set_name); wrap.remove(); }); row.appendChild(btn);
    }
    wrap.appendChild(row); addManualCorrectionRow(wrap,item); els.resolveList.appendChild(wrap);
  }
}

/* Import handlers */
els.importCSV.addEventListener('change', async (e)=>{
  const file=e.target.files?.[0]; if(!file) return; show(els.csvBox); els.csvProgress.value=0; els.csvNote.textContent=`Reading ${file.name}…`;
  try{
    const raw=await file.text(); const {csvText, header:externalHeader}=peelCsvHeader(raw); const rows=parseCSV(csvText);
    if(!rows.length){ els.csvNote.textContent='No rows found.'; e.target.value=''; return; }
    let headerRaw,dataRows; if(externalHeader){ headerRaw=externalHeader; dataRows=rows; } else { headerRaw=rows[0]; dataRows=rows.slice(1); }
    const header=headerRaw.map(h=>(h||'').toString().trim().toLowerCase().replace(/[^a-z0-9]/g,'')); const col=(name)=>header.indexOf(name.toLowerCase().replace(/[^a-z0-9]/g,''));
    const iName=col('cardname'), iQty=col('quantity'), iSetCode=col('setcode'), iSetName=col('setname');
    if(iName===-1 || iQty===-1){ alert('CSV must include at least Card Name and Quantity columns.'); e.target.value=''; return; }
    const strict=false; const increments={}; const unmatched=[]; const total=dataRows.length; let processed=0;
    for(const row of dataRows){
      if(!row||!row.length){ processed++; continue; }
      const name=(row[iName]||'').trim(); const qty=parseInt((row[iQty]||'0').trim(),10)||0; const setCode=iSetCode>=0?(row[iSetCode]||'').trim():''; const setName=iSetName>=0?(row[iSetName]||'').trim():'';
      if(!name||qty<=0){ processed++; continue; }
      const nameLC=name.toLowerCase(); let candidates=await db.cards.where('name_lc').equals(nameLC).toArray();
      if(!candidates.length) candidates=await db.cards.where('name_lc').startsWith(nameLC).toArray();
      let card=null; if(candidates.length) card=selectCardByNameAndSet(candidates,setCode,setName,strict);
      if(!card) unmatched.push({row:processed+2,name,setCode,setName,qty});
      else increments[card.id]=(increments[card.id]||0)+qty;
      processed++; if(processed%50===0 || processed===total){ els.csvProgress.value=Math.round(processed/Math.max(1,total)*100); els.csvNote.textContent=`Matched ${Object.keys(increments).length} unique; ${unmatched.length} unmatched…`; await sleep(0); }
    }
    const ids=Object.keys(increments);
    await db.transaction('rw', db.collection, async ()=>{ for(const id of ids){ const cur=await db.collection.get(id)||{id,qty:0}; cur.qty+=increments[id]; await db.collection.put(cur); } });
    els.csvProgress.value=100; const totalAdded=Object.values(increments).reduce((a,b)=>a+b,0);
    els.csvNote.textContent=`Imported ${ids.length} unique; added ${totalAdded} total. Unmatched: ${unmatched.length}.`;
    await refreshStats(); els.status.textContent='Added cards to collection.'; search();
    if(unmatched.length) renderResolveUnmatched(unmatched); else { hide(els.resolveBox); els.resolveList.innerHTML=''; }
    hideStatusBars();
  }catch(err){ console.error(err); alert('Failed to import CSV.'); }
  e.target.value='';
});

els.importTXT.addEventListener('change', async (e)=>{
  const file=e.target.files?.[0]; if(!file) return; show(els.csvBox); els.csvProgress.value=0; els.csvNote.textContent=`Reading ${file.name}…`;
  try{
    const text=await file.text(); const rows=parseScannerTXT(text); if(!rows.length){ els.csvNote.textContent='No recognizable rows found in TXT.'; e.target.value=''; hideStatusBars(); return; }
    const increments={}, unmatched=[]; const total=rows.length; let processed=0;
    for(const item of rows){
      const {name,qty}=item; const setName=item.setName||''; if(!name||qty<=0){ processed++; continue; }
      const nameLC=name.toLowerCase(); let candidates=await db.cards.where('name_lc').equals(nameLC).toArray(); if(!candidates.length) candidates=await db.cards.where('name_lc').startsWith(nameLC).toArray();
      let card=null; if(candidates.length){ if(setName){ const sn=setName.toLowerCase(); card=candidates.find(c=>(c.set_name||'').toLowerCase()===sn)||null; } if(!card) card=candidates[0]||null; }
      if(!card) unmatched.push({row:item.row, name, setCode:'', setName, qty}); else increments[card.id]=(increments[card.id]||0)+qty;
      processed++; if(processed%50===0 || processed===total){ els.csvProgress.value=Math.round(processed/Math.max(1,total)*100); els.csvNote.textContent=`Matched ${Object.keys(increments).length} unique; ${unmatched.length} unmatched…`; await sleep(0); }
    }
    const ids=Object.keys(increments); await db.transaction('rw', db.collection, async ()=>{ for(const id of ids){ const cur=await db.collection.get(id)||{id,qty:0}; cur.qty+=increments[id]; await db.collection.put(cur); } });
    els.csvProgress.value=100; const totalAdded=Object.values(increments).reduce((a,b)=>a+b,0);
    els.csvNote.textContent=`TXT add: ${ids.length} unique; +${totalAdded} total. Unmatched: ${unmatched.length}.`;
    await refreshStats(); els.status.textContent='Added cards to collection.'; search();
    if(unmatched.length) renderResolveUnmatched(unmatched); else { hide(els.resolveBox); els.resolveList.innerHTML=''; } hideStatusBars();
  }catch(err){ console.error(err); alert('Failed to import TXT.'); }
  e.target.value='';
});

/* Clear actions */
els.btnClearDB.addEventListener('click', async()=>{ if(!confirm('Delete ALL cards from local DB? This does NOT remove your collection.')) return; await db.cards.clear(); await refreshStats(); els.results.innerHTML=''; els.status.textContent='Cleared DB.'; });
els.btnClearCollection.addEventListener('click', async()=>{ if(!confirm('Clear your collection quantities?')) return; await db.collection.clear(); await refreshStats(); document.querySelectorAll('.qty-in').forEach(el=>el.value=0); els.status.textContent='Cleared collection.'; });

/* =================== Deck Mode =================== */
const deck = {
  name:'Untitled', id:null,
  format:'commander', singleton:true, colorLock:true, proxies:false,
  commander:null, // card object
  entries:new Map(), // cardId -> qty
  // derived
  get target(){ return this.format==='sixty'? 60 : 100; },
  get size(){ let n=0; for(const q of this.entries.values()) n+=q; return n + (this.commander? (this.format==='commander'? 1:0):0); },
  get colors(){ return this.commander? (this.commander.color_identity || []) : []; },
  clear(){ this.name='Untitled'; this.id=null; this.entries.clear(); this.commander=null; },
  toJSON(){ return { name:this.name, format:this.format, singleton:this.singleton, colorLock:this.colorLock, proxies:this.proxies,
    commanderId:this.commander?.id||null, entries:[...this.entries.entries()], updated_at: Date.now() }; },
  fromJSON(d){ this.name=d.name||'Untitled'; this.format=d.format||'commander'; this.singleton=!!d.singleton; this.colorLock=!!d.colorLock; this.proxies=!!d.proxies;
    this.entries=new Map(d.entries||[]); return this; }
};
Object.defineProperty(deck,'state',{ get(){ return { singleton:deck.singleton, colorLock:deck.colorLock, proxies:deck.proxies }; } });

function updateDeckUI(){
  els.deckFormat.value = deck.format;
  els.deckSingleton.checked = deck.singleton;
  els.deckColorLock.checked = deck.colorLock;
  els.deckProxies.checked = deck.proxies;

  els.kDeckTarget.textContent = deck.target;
  els.kDeckSize.textContent = deck.size;
  els.deckProg.max = deck.target; els.deckProg.value = Math.min(deck.target, deck.size);
  els.deckStatus.textContent = `${deck.format==='sixty'?'60-card':'Commander'} • ${deck.size}/${deck.target}`;

  // Commander label
  els.cmdrPrimary.textContent = deck.commander? deck.commander.name : 'None';
  show(els.commanderSec);

  // Build deck list groups
  const grouped = { Creatures:[], Noncreatures:[], Lands:[] };
  for(const [id,qty] of deck.entries.entries()){
    const c = window.__cardsById[id] || null;
    if(!c){ continue; }
    const tl = (c.type_lc||'');
    const g = /land/.test(tl) ? 'Lands' : (/creature/.test(tl) ? 'Creatures' : 'Noncreatures');
    grouped[g].push({card:c,qty});
  }
  let html='';
  for(const sec of ['Creatures','Noncreatures','Lands']){
    const arr=grouped[sec];
    if(!arr.length) continue;
    html+=`<div class="tiny" style="margin-top:8px;margin-bottom:6px;color:#9aa4ad">${sec}</div>`;
    for(const {card,qty} of arr){
      const avail=(latestOwnedMap[card.id]||0) - (deck.entries.get(card.id)||0);
      html+=`<div class="deck-row">
        <div class="slot">
          <span class="badge">${qty}×</span>
          <strong title="${card.type_line}">${card.name}</strong>
        </div>
        <div class="row">
          <span class="tiny">avail ${Math.max(0,avail)}</span>
          <button class="mini-btn" onclick="addToDeck('${card.id}',-1)">−</button>
          <button class="mini-btn" onclick="addToDeck('${card.id}',+1)">＋</button>
          <button class="mini-btn" onclick="removeFromDeck('${card.id}')">Remove</button>
        </div>
      </div>`;
    }
  }
  els.deckList.innerHTML = html || `<div class="tiny">No cards yet. Drag from results here or use “Add to Deck”.</div>`;

  // Stats
  const stats = computeStats();
  els.kCreatures.textContent = stats.creatures;
  els.kNoncreatures.textContent = stats.noncreatures;
  els.kLands.textContent = stats.lands;
  els.sAvgCmc.textContent = stats.avgCmc.toFixed(2);
  els.sPips.textContent = `${stats.pips.W}/${stats.pips.U}/${stats.pips.B}/${stats.pips.R}/${stats.pips.G}`;
  els.sCurveTxt.textContent = stats.curve.map((n,i)=>`${i}:${n}`).join('  ');

  // Legality hints
  const warns=[];
  if(deck.format==='commander'){
    if(deck.size<deck.target) warns.push(`Need ${deck.target-deck.size} more card(s).`);
    if(deck.singleton){
      const dups = [...deck.entries.entries()].filter(([id,q])=>q>1);
      if(dups.length) warns.push('Singleton violated: '+dups.length+' card(s) >1 copy.');
    }
    if(deck.commander){
      const lock=deck.colors; for(const [id] of deck.entries){
        const c=window.__cardsById[id]; if(!c) continue;
        const bad = (c.color_identity||[]).some(x=>!lock.includes(x));
        if(bad){ warns.push(`Color identity violation: ${c.name}`); break; }
      }
    } else warns.push('No commander chosen.');
  }else{ // 60-card
    if(deck.size<deck.target) warns.push(`Need ${deck.target-deck.size} more card(s).`);
    const tooMany=[...deck.entries.entries()].filter(([id,q])=>q>4);
    if(tooMany.length) warns.push('4-of rule violated for '+tooMany.length+' card(s).');
  }
  if(!deck.proxies){
    const shortage=[...deck.entries.entries()].filter(([id,q])=> (latestOwnedMap[id]||0) < q);
    if(shortage.length) warns.push('Ownership: '+shortage.length+' card(s) exceed what you own.');
  }
  if(warns.length){ els.deckLegalMsg.style.display=''; els.deckLegalMsg.textContent=warns.join(' '); }
  else { els.deckLegalMsg.style.display='none'; }

  // Suggestions & cuts
  renderSuggestions(stats);
  renderCuts(stats);
}

function computeStats(){
  const stats={ creatures:0, noncreatures:0, lands:0, avgCmc:0, curve:[0,0,0,0,0,0,0,0], pips:{W:0,U:0,B:0,R:0,G:0} };
  let totalCmc=0, totalCards=0;
  for(const [id,qty] of deck.entries){
    const c = window.__cardsById[id]; if(!c) continue;
    const tl=(c.type_lc||'');
    if(/land/.test(tl)) stats.lands+=qty; else if(/creature/.test(tl)) stats.creatures+=qty; else stats.noncreatures+=qty;
    const cmc = Number(c.cmc||0); totalCmc += cmc*qty; totalCards += qty;
    const bucket = Math.max(0, Math.min(7, Math.floor(cmc))); stats.curve[bucket]+=qty;
    for(const sym of (c.mana_cost||'').match(/\{[WUBRG]\}/g)||[]){ const k=sym.replace(/[{}]/g,''); stats.pips[k]++; }
  }
  // commander counted too? In EDH commander is part of 100; add into totals for curve/cmcs (optional). We'll keep deck entries only.
  stats.avgCmc = totalCards? (totalCmc/totalCards) : 0;
  return stats;
}

/* Drag & drop to deck */
function dragCard(ev,id){ ev.dataTransfer.setData('text/plain', id); }
els.deckDrop.addEventListener('dragover',(e)=>{ e.preventDefault(); els.deckDrop.classList.add('drag'); });
els.deckDrop.addEventListener('dragleave',()=>els.deckDrop.classList.remove('drag'));
els.deckDrop.addEventListener('drop',(e)=>{ e.preventDefault(); els.deckDrop.classList.remove('drag'); const id=e.dataTransfer.getData('text/plain'); if(id) addToDeck(id,1); });

/* Deck operations */
async function ensureCardCached(id){
  if(!window.__cardsById[id]){ const c=await db.cards.get(id); if(c) window.__cardsById[id]=c; }
}
window.addToDeck = async function(id, delta){
  await ensureCardCached(id);
  const card=window.__cardsById[id]; if(!card) return;

  // color identity lock
  if(deck.colorLock && deck.commander){
    for(const c of (card.color_identity||[])) if(!(deck.colors||[]).includes(c)){ alert(`Color identity lock: ${card.name} not in ${deck.colors.join('')||'colorless'}.`); return; }
  }
  // singleton / 4-of
  const cur=deck.entries.get(id)||0; const next=cur + (delta||0);
  if(next<0) return; if(next===0) { deck.entries.delete(id); } else {
    if(deck.format==='commander' && deck.singleton && next>1){ alert('Singleton rule: only 1 copy allowed.'); return; }
    if(deck.format==='sixty' && next>4){ alert('4-of rule in 60-card formats.'); return; }
    // ownership
    if(!deck.proxies){
      const have=latestOwnedMap[id]||0; if(next>have){ alert(`You own only ${have} of ${card.name}.`); return; }
    }
    deck.entries.set(id, next);
  }
  updateDeckUI(); search(); // update availability badges
};
window.removeFromDeck = function(id){ deck.entries.delete(id); updateDeckUI(); search(); };

window.setCommander = async function(id){
  await ensureCardCached(id); const card=window.__cardsById[id]; if(!card) return;
  if(!isPotentialCommanderFront(card)){ alert('Front face is not a legendary creature/vehicle or has no “can be your commander” text.'); return; }
  deck.commander = card; updateDeckUI(); search();
};
els.btnClearCmdr.addEventListener('click',()=>{ deck.commander=null; updateDeckUI(); search(); });

/* Deck save/load/delete */
async function refreshSavedDecks(){
  const list=await db.decks.toArray(); els.savedDecks.innerHTML = list.map(d=>`<option value="${d.id}">${d.name||'Untitled'} — ${new Date(d.updated_at||Date.now()).toLocaleString()}</option>`).join('');
}
els.btnSaveDeck.addEventListener('click', async()=>{
  const name = prompt('Deck name', deck.name||'Untitled'); if(name==null) return; deck.name=name;
  // persist commanderId mapping
  const payload = deck.toJSON();
  // ensure cards cached
  if(payload.commanderId && !window.__cardsById[payload.commanderId]) window.__cardsById[payload.commanderId]=await db.cards.get(payload.commanderId);
  if(deck.id){ await db.decks.update(deck.id, {...payload, updated_at:Date.now()}); }
  else{ const id = await db.decks.add({...payload, updated_at:Date.now()}); deck.id=id; }
  await refreshSavedDecks(); alert('Saved!');
});
els.btnNewDeck.addEventListener('click', ()=>{ deck.clear(); deck.format='commander'; deck.singleton=true; deck.colorLock=true; deck.proxies=false; updateDeckUI(); search(); });
els.btnLoadDeck.addEventListener('click', async()=>{
  const id=Number(els.savedDecks.value); if(!id) return;
  const d=await db.decks.get(id); if(!d) return;
  deck.clear(); deck.id=id; deck.fromJSON(d); deck.format=d.format||'commander'; deck.singleton=!!d.singleton; deck.colorLock=!!d.colorLock; deck.proxies=!!d.proxies;
  if(d.commanderId){ deck.commander = await db.cards.get(d.commanderId); if(deck.commander) window.__cardsById[deck.commander.id]=deck.commander; }
  for(const [cid] of deck.entries) { if(!window.__cardsById[cid]) window.__cardsById[cid]=await db.cards.get(cid); }
  updateDeckUI(); search();
});
els.btnDeleteDeck.addEventListener('click', async()=>{
  const id=Number(els.savedDecks.value); if(!id) return; if(!confirm('Delete this saved deck?')) return;
  await db.decks.delete(id); if(deck.id===id) { deck.clear(); updateDeckUI(); search(); } await refreshSavedDecks();
});

/* Format toggles */
els.deckFormat.addEventListener('change',()=>{ deck.format=els.deckFormat.value; deck.singleton=(deck.format==='commander'); els.deckSingleton.checked=deck.singleton; updateDeckUI(); });
els.deckSingleton.addEventListener('change',()=>{ deck.singleton=els.deckSingleton.checked; updateDeckUI(); });
els.deckColorLock.addEventListener('change',()=>{ deck.colorLock=els.deckColorLock.checked; updateDeckUI(); search(); });
els.deckProxies.addEventListener('change',()=>{ deck.proxies=els.deckProxies.checked; updateDeckUI(); });

/* Land helper */
els.btnSuggestLands.addEventListener('click',()=>{
  const n=parseInt(els.landCount.value,10)||0; const pips=computeStats().pips;
  const total = pips.W+pips.U+pips.B+pips.R+pips.G;
  if(total===0){ els.landSuggest.textContent='No colored pips yet.'; return; }
  const split = { W:Math.round(n*pips.W/total), U:Math.round(n*pips.U/total), B:Math.round(n*pips.B/total), R:Math.round(n*pips.R/total), G:Math.round(n*pips.G/total) };
  // adjust rounding to sum n
  let sum=split.W+split.U+split.B+split.R+split.G; while(sum<n){ // add to max frac
    const arr=[['W',pips.W],['U',pips.U],['B',pips.B],['R',pips.R],['G',pips.G]].sort((a,b)=>b[1]-a[1]); split[arr[0][0]]++; sum++;
  } while(sum>n){ const arr=[['W',pips.W],['U',pips.U],['B',pips.B],['R',pips.R],['G',pips.G]].sort((a,b)=>a[1]-b[1]); split[arr[0][0]]--; sum--; }
  els.landSuggest.textContent = `Basics → Plains ${split.W}, Islands ${split.U}, Swamps ${split.B}, Mountains ${split.R}, Forests ${split.G}`;
});

/* Packages */
const pkgRules = {
  ramp: (c)=> /\b(add|pay)\s*\{[WUBRG]\}/i.test(c.oracle_text||'') || /\bsearch.*(land|basic)/i.test((c.oracle_text||'')),
  draw: (c)=> /\bdraw\b/i.test(c.oracle_text||''),
  removal: (c)=> /\bdestroy\b|\bexile\b|\bcounter target\b/i.test(c.oracle_text||''),
  wipes: (c)=> /\bdestroy all\b|\ball creatures get\b|\b-?X\/-?X until end of turn\b/i.test(c.oracle_text||'')
};
els.pkgRow.addEventListener('click', async (e)=>{
  const btn=e.target.closest('button[data-pkg]'); if(!btn) return;
  const kind=btn.dataset.pkg;
  const owned = await db.collection.where('qty').above(0).toArray();
  const cards = await db.cards.bulkGet(owned.map(e=>e.id));
  const lock= (deck.colorLock && deck.commander)? new Set(deck.colors) : null;
  const matches=[];
  for(const c of cards){
    if(!c) continue;
    if(lock){ if((c.color_identity||[]).some(x=>!lock.has(x))) continue; }
    if(pkgRules[kind](c)) matches.push(c);
  }
  // add up to 5 best (lowest cmc first)
  matches.sort((a,b)=>(a.cmc||0)-(b.cmc||0));
  let added=0;
  for(const c of matches.slice(0,5)){
    await ensureCardCached(c.id);
    if(deck.format==='commander' && deck.singleton && deck.entries.get(c.id)) continue;
    if(!deck.proxies && (latestOwnedMap[c.id]||0) <= (deck.entries.get(c.id)||0)) continue;
    deck.entries.set(c.id, (deck.entries.get(c.id)||0)+1); added++;
  }
  updateDeckUI(); search();
  els.pkgNote.textContent = added? `Added ${added} ${kind} card(s).` : `No eligible ${kind} found.`;
});

/* Suggestions based on commander subtype/keywords */
function commanderKeywords(c){
  const tl=(c?.type_lc||''); const ot=(c?.oracle_text||'').toLowerCase();
  const subs = (tl.split('—')[1]||'').toLowerCase().split(/[—–-]|,|\s+/).map(s=>s.trim()).filter(Boolean);
  const hints=[];
  for(const s of subs){ if(!hints.includes(s)) hints.push(s); }
  ['equipment','aura','artifact','zombie','goblin','elf','merfolk','vampire','pirate','treasure','sacrifice','token','landfall','proliferate','graveyard','blink','counter','draw','discard','mill']
    .forEach(k=>{ if(ot.includes(k) && !hints.includes(k)) hints.push(k); });
  return hints.slice(0,5);
}
async function renderSuggestions(stats){
  if(!deck.commander){ els.suggestions.innerHTML='Pick a commander to see synergy.'; return; }
  const hints=commanderKeywords(deck.commander);
  const owned = await db.collection.where('qty').above(0).toArray();
  const cards = await db.cards.bulkGet(owned.map(e=>e.id));
  const lock= deck.colorLock? new Set(deck.colors) : null;
  const cand=[];
  for(const c of cards){
    if(!c) continue;
    if(lock){ if((c.color_identity||[]).some(x=>!lock.has(x))) continue; }
    const hay=((c.type_lc||'') + ' ' + (c.oracle_text||'').toLowerCase());
    if(hints.some(h=>hay.includes(h))){ cand.push(c); }
  }
  // rank by cmc then name
  cand.sort((a,b)=> (a.cmc||0)-(b.cmc||0) || a.name.localeCompare(b.name));
  const top=cand.slice(0,10);
  els.suggestions.innerHTML = top.length? top.map(c=>`<div class="deck-row">
    <div class="slot"><strong>${c.name}</strong> <span class="tiny">${c.type_line}</span></div>
    <button class="mini-btn" onclick="addToDeck('${c.id}',1)">Add</button>
  </div>`).join('') : 'No obvious synergies found.';
}

/* Cuts helper: surface highest CMC + off-plan cards */
function renderCuts(stats){
  const list=[...deck.entries.entries()].map(([id,qty])=>({ card:window.__cardsById[id], qty }));
  if(!list.length){ els.cuts.textContent='Add more cards to see easy trims.'; return; }
  // rank: high CMC first; deprioritize lands; off-color (should be filtered) and type redundancy
  list.sort((a,b)=> ((b.card?.cmc||0)-(a.card?.cmc||0)) );
  const top=list.slice(0,8);
  els.cuts.innerHTML = top.map(o=>`<div class="deck-row">
    <div class="slot"><strong>${o.card?.name||'?'}</strong> <span class="tiny">CMC ${o.card?.cmc??0}</span></div>
    <button class="mini-btn" onclick="addToDeck('${o.card?.id}',-1)">Cut −1</button>
  </div>`).join('');
}

/* Exporters */
function deckAsList(){
  const lines=[];
  if(deck.commander && deck.format==='commander') lines.push(`1 ${deck.commander.name} (Commander)`);
  const items=[...deck.entries.entries()].map(([id,qty])=>({ card:window.__cardsById[id], qty })).filter(x=>x.card);
  items.sort((a,b)=> a.card.name.localeCompare(b.card.name));
  for(const {card,qty} of items) lines.push(`${qty} ${card.name}`);
  return lines.join('\n');
}
els.expText.addEventListener('click',()=>{ const txt=deckAsList(); els.expOut.textContent=txt; });
els.expMtgo.addEventListener('click',()=>{ const lines=deckAsList().split('\n').map(s=>s.replace(' (Commander)','')); els.expOut.textContent=lines.join('\n'); });
els.expMox.addEventListener('click',()=>{ const txt=btoa(unescape(encodeURIComponent(deckAsList()))); els.expOut.textContent=`mox:${txt}`; });

/* =================== Misc UI: search panel collapse on mobile =================== */
function isMobile(){ return window.innerWidth <= MOBILE_BP; }
function setSearchExpanded(expanded){ const p=els.searchPanel; if(!p) return; p.classList.toggle('collapsed', !expanded); els.searchHead?.setAttribute('aria-expanded', expanded?'true':'false'); }
function expandSearch(){ setSearchExpanded(true); }
function collapseSearch(){ setSearchExpanded(false); }
function onScrollCollapse(){ if(!isMobile()){ expandSearch(); return; } if(Date.now()<suppressAutoUntil) return; const y=window.scrollY||document.documentElement.scrollTop||0; setSearchExpanded(!(y>COLLAPSE_THRESHOLD)); }
window.addEventListener('scroll', onScrollCollapse, {passive:true}); window.addEventListener('resize', onScrollCollapse);
onScrollCollapse();
els.searchHead?.addEventListener('click',()=>{ if(window.innerWidth>900) return; const isCollapsed=els.searchPanel.classList.contains('collapsed'); els.searchPanel.classList.toggle('collapsed', !isCollapsed); suppressAutoUntil=Date.now()+800; });
$all('section.panel.details input, section.panel.details select').forEach(el=>el.addEventListener('focus', expandSearch));
els.btnSearch.addEventListener('click', ()=>{ if(isMobile()) collapseSearch(); search(); });
['qName','qText','qType','qSubtype','qRarity'].forEach(id=>document.getElementById(id).addEventListener('keydown',e=>{ if(e.key==='Enter') search(); }));
$all('.ci').forEach(el=>el.addEventListener('change', search));
if(els.colorMode) els.colorMode.addEventListener('change', search);
if(els.filterCommander) els.filterCommander.addEventListener('change', search);

/* Price toggle */
window.updateCardPrice=function(id){ const card=window.__cardsById[id]; if(!card) return; const holo=!!document.getElementById(`holo-${id}`)?.checked; const el=document.getElementById(`price-${id}`); if(el) el.textContent=getUsdPrice(card,holo)||'—'; };

/* Deck panel open/close */
els.btnDeck.addEventListener('click',()=>{ els.deckPanel.classList.add('open'); });
els.btnCloseDeck.addEventListener('click',()=>{ els.deckPanel.classList.remove('open'); });

/* Startup */
window.addEventListener('DOMContentLoaded', async ()=>{
  try{ await importNDJSONFromURL(NDJSON_URL, {skipIfUnchanged:true}); } catch(e){ console.error(e); els.status.textContent='Remote import failed.'; els.importNote.textContent=`Error: ${e?.message||e}`; }
  await refreshStats(); await refreshSavedDecks(); updateDeckUI(); search();
});
</script>
</body>
</html>
