<!doctype html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG Collection Browser</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="icon" href="data:,">
  <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.min.js"></script>
<style>
  /* ===== Theme ===== */
  :root{
    --bg:#0b0d0f;           /* base */
    --bg-2:#0f1317;         /* slightly lighter */
    --panel:#12161a;
    --muted:#9aa4ad;
    --text:#e8edf2;
    --accent:#6ee7ff;       /* cyan */
    --accent-2:#a78bfa;     /* violet */
    --danger:#ff7d7d;
    --card:#171c22;
    --chip:#1b222a;
    --border:#24303a;
    --btn-fs: 14px;      /* tweak here if you want smaller/larger */
    --btn-lh: 1.15;
    --btn-fw: 600;
  }
  .btn,
  a.btn,
  label.btn{
    font-size: var(--btn-fs);
    line-height: var(--btn-lh);
    font-weight: var(--btn-fw);
    display: inline-flex;            /* consistent layout */
    align-items: center;
    gap: 10px;
  }
  label.btn input[type="file"],
  label.btn input[type="checkbox"]{
    font-size: inherit;
    line-height: inherit;
  }
  
  html { min-height: 100%; -webkit-text-size-adjust: 100%; text-size-adjust: 100%;  }          /* let the page be at least as tall as the viewport */
  body { 
    min-height: 100vh;                /* fallback */
    min-height: 100dvh;               /* modern browsers */
  }

  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial}

  /* Subtle starfield/grid background */
body{
  background:
    radial-gradient(1200px 600px at 70% -10%, #1b24311f, transparent),
    radial-gradient(1000px 600px at -10% 110%, #1b24311a, transparent),
    repeating-linear-gradient(90deg, #ffffff06 0 1px, #0000 1px 20px),
    repeating-linear-gradient(0deg,  #ffffff06 0 1px, #0000 1px 20px),
    var(--bg);
  background-attachment: fixed, fixed, fixed, fixed, fixed;
}

  a{color:var(--accent)}
  .wrap{max-width:1200px;margin:0 auto;padding:20px}

  header{display:flex;align-items:center;gap:14px;flex-wrap:wrap;margin-bottom:16px}
  header .title{
    font-weight:900; letter-spacing:.3px; font-size:24px; line-height:1.1;
    background:linear-gradient(90deg,var(--accent),var(--accent-2));
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 0 18px #6ee7ff22;
  }

  .bar{display:flex;gap:10px;flex-wrap:wrap}

  /* ===== Fancy buttons ===== */
  .btn{
    position:relative;
    background:linear-gradient(var(--panel),var(--panel)) padding-box,
               linear-gradient(120deg,var(--border),#2d3a46) border-box;
    border:1px solid transparent;
    color:var(--text);
    padding:10px 14px; border-radius:12px; cursor:pointer; text-decoration:none;
    transition:transform .15s ease, box-shadow .2s ease, border-color .2s ease;
  }
  .btn:hover{
    border-image:linear-gradient(120deg,var(--accent),var(--accent-2)) 1;
    box-shadow:0 0 0 3px #6ee7ff1a, 0 6px 18px #0008;
    transform:translateY(-1px);
  }
  .btn:focus-visible{outline:none; box-shadow:0 0 0 3px #6ee7ff55, 0 0 0 6px #6ee7ff22}
  .btn.danger:hover{border-image:linear-gradient(120deg,#ff7d7d,#ffb3b3) 1}

  .ghost{background:transparent}

  .file{position:relative;overflow:hidden}
  .file input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer}

  /* ==== Combo bubble & popover ==== */
  .combo-wrap{ position: relative; display:inline-block; }
  .combo-chip.btn{
    background: linear-gradient(90deg,var(--accent),var(--accent-2)) padding-box,
                linear-gradient(120deg,var(--border),#2d3a46) border-box;
    border:1px solid transparent;
    color:#0b0d0f; font-weight:800;
    text-shadow: 0 1px 0 #ffffff60;
  }
  .combo-chip.btn:hover{
    box-shadow: 0 0 0 4px #6ee7ff2a, 0 10px 24px #0008;
    transform: translateY(-1px);
  }
  
  .combo-pop{
    position:absolute; top: calc(100% + 8px); right: 0;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px; padding: 10px;
    min-width: 240px; max-width: 320px;
    box-shadow: 0 16px 40px #000a;
    display: none;
  }
  .combo-wrap:hover .combo-pop,
  .combo-wrap:focus-within .combo-pop { display:block; }
  
  /* small tile grid */
  .combo-grid{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
  }
  .combo-item{
    position:relative;
    border-radius:10px; overflow:hidden;
    border:1px solid var(--border);
    background:#0f1114;
    aspect-ratio: 3/4;
  }
  .combo-item img{
    width:100%; height:100%; object-fit:cover; display:block;
    transform: translateZ(0);
  }
  .combo-owned{
    position:absolute; left:6px; top:6px;
    background:linear-gradient(#1e2a22,#1b2420) padding-box,
               linear-gradient(90deg,#2d3a46,#24303a) border-box;
    border:1px solid transparent; border-radius:999px;
    padding:2px 6px; font-size:11px; color:#c6f6d5;
  }
  .combo-miss{
    position:absolute; left:6px; top:6px;
    background:#2a1a1a; border:1px solid #3a2525; color:#ffb3b3;
    border-radius:999px; padding:2px 6px; font-size:11px;
  }
  .combo-title{
    margin:0 0 6px 0; font-size:12px; color:var(--muted);
  }
  
  /* ===== Layout ===== */
  .grid{display:grid;grid-template-columns:320px 1fr;gap:16px;align-items:start}
/* Mobile: collapse the Search panel into a single header line */
@media (max-width: 900px){
  .grid{ grid-template-columns: 1fr; }
  .details { position: sticky; top: 12px; z-index: 30; }
  
  .details .head{
    cursor: pointer;
    position: relative;
    z-index: 2;
  }
  .details .body{
    position: relative; z-index: 1;
    overflow: hidden;
    max-height: 1000px;            /* expanded */
    opacity: 1;
    transform: translateY(0);
    transform-origin: top;
    transition:
      max-height 220ms ease,
      opacity 180ms ease,
      transform 220ms ease;
  }
  .details.collapsed .body{
    max-height: 0;                          /* collapsed */
    opacity: 0;
    transform: translateY(-6px);
    pointer-events: none;                    /* avoid accidental taps */
  }

  /* rounded “chip” look when collapsed */
  .details.collapsed .head{
    border-bottom: none;
    border-radius: 14px;
    box-shadow: 0 8px 24px #0008;
    background: var(--panel);
    transition: border-radius 220ms ease, box-shadow 220ms ease, background 220ms ease;
  }

  /* hint text on mobile */
  .details .head strong::after{
    content: ' — tap to expand';
    font-weight: 500; color: var(--muted); margin-left: 6px; font-size: 12px;
  }
  .details:not(.collapsed) .head strong::after{ content: ''; }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  .details .body{ transition: none !important; }
}


  /* ===== Panels with gradient borders (subtle) ===== */
  .panel{
    position:relative;
    background:linear-gradient(var(--panel),var(--panel)) padding-box,
               linear-gradient(135deg,#22303b,#161d22,#22303b) border-box;
    border:1px solid transparent;
    border-radius:16px;
    box-shadow:0 8px 24px #0008;
  }
  .panel .head{
    padding:14px 16px;border-bottom:1px solid var(--border);
    display:flex;align-items:center;justify-content:space-between;gap:12px
  }
  .panel .body{padding:14px 16px}

  .muted{color:var(--muted)}
  .muted.small{opacity:.9}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .grow{flex:1 1 auto}

  /* ===== Inputs ===== */
  input[type=text],select{
    background:linear-gradient(var(--card),var(--card)) padding-box,
               linear-gradient(120deg,#2b3946,#1d252d) border-box;
    color:var(--text); border:1px solid transparent; border-radius:12px;
    padding:10px 12px; width:100%; transition:box-shadow .2s ease,border-image .2s ease;
  }
  input[type=text]::placeholder{color:#9aa4adcc}
  input[type=text]:focus, select:focus{
    outline:none;
    border-image:linear-gradient(120deg,var(--accent),var(--accent-2)) 1;
    box-shadow:0 0 0 3px #6ee7ff2a;
  }

  /* Dark dropdowns */
  :root { color-scheme: dark; }  /* hint to form controls & scrollbars */
  
  select {
    background: linear-gradient(var(--card), var(--card)) padding-box,
                linear-gradient(120deg,#2b3946,#1d252d) border-box;
    color: var(--text);
    border: 1px solid transparent;
  }
  
  /* The popup list */
  select option,
  select optgroup {
    background-color: var(--panel);
    color: var(--text);
  }
  
  /* Highlight states inside the popup (when supported) */
  select option:hover,
  select option:checked {
    background-color: #1a232b;
    color: var(--text);
  }

  /* ===== Chips / color identity ===== */
  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    background:var(--chip); border:1px solid var(--border);
    padding:6px 10px; border-radius:999px; font-size:12px;
    transition:transform .12s ease, box-shadow .2s ease, border-image .2s ease;
  }
  .chip input{accent-color:var(--accent)}
  .colors{display:flex;gap:6px}
  .dot{width:14px;height:14px;border-radius:999px;border:1px solid #0006;box-shadow:0 0 0 1px #0004 inset}
  .W{background:#f9f5d7}.U{background:#79a6ff}.B{background:#5c5c5c}.R{background:#ff8f8f}.G{background:#67c77a}.C{background:#cbd5e1}

  /* Highlight chip when checked (modern browsers) */
  label.chip:has(input:checked){
    background:linear-gradient(90deg,#1c2430,#1d2732) padding-box,
               linear-gradient(90deg,var(--accent),var(--accent-2)) border-box;
    border:1px solid transparent;
    box-shadow:0 0 0 3px #6ee7ff22;
    transform:translateY(-1px);
  }

  /* ===== Results grid & cards ===== */
  .results{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}

  .card{
    background:linear-gradient(var(--card),var(--card)) padding-box,
               linear-gradient(145deg,#22313e,#161e24) border-box;
    border:1px solid transparent;
    border-radius:14px; overflow:hidden; display:flex; flex-direction:column;
    transition:transform .18s ease, box-shadow .25s ease, border-image .2s ease;
  }
  .card:hover{
    transform:translateY(-3px);
    border-image:linear-gradient(145deg,var(--accent),var(--accent-2)) 1;
    box-shadow:0 14px 30px #000a, 0 0 0 4px #6ee7ff14 inset;
  }
  .card img{
    width:100%; aspect-ratio:3/4; object-fit:cover; display:block; background:#0f1114;
    transform:translateZ(0); transition:transform .25s ease, filter .25s ease;
    filter:saturate(1.02) contrast(1.02);
  }
  .card:hover img{ transform:scale(1.03) }
  .card .meta{padding:12px 12px 14px;display:flex;flex-direction:column;gap:8px}
  .card .line{display:flex;align-items:center;justify-content:space-between;gap:8px}

  .qty{display:flex;align-items:center;gap:6px}
  .qty .btn.ghost{border-color:#2b3946}
  .qty input{width:56px;text-align:center;background:#0d1117;border:1px solid #2a3742;border-radius:10px;color:var(--text);padding:6px}

  .stat{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;
    background:linear-gradient(#202a33,#1a232b) padding-box, linear-gradient(90deg,#2d3a46,#24303a) border-box;
    border:1px solid transparent;border-radius:999px;font-size:12px}

  .chip, .stat{white-space:nowrap}

  .details{position:sticky;top:16px}

  progress{width:100%;height:12px;accent-color:var(--accent)}
  progress::-webkit-progress-bar{background:#0f1419;border-radius:999px}
  progress::-webkit-progress-value{background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:999px}

  .small{font-size:12px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Monaco,monospace;background:#0d1117;border:1px solid #30363d;padding:2px 6px;border-radius:6px;font-size:12px}

  .test-pass{color:#9fff9f}.test-fail{color:#ff9f9f}
  .muted2{color:#8b95a1}
  .inline-msg{font-size:12px;color:var(--muted)}
  .err{color:#ffb3b3}
  .suggest{color:#c6f6d5}

  /* Status pill in Results header */
  #status{
    background:linear-gradient(#1a222a,#1a222a) padding-box,
               linear-gradient(90deg,#2e3b47,#24303a) border-box;
    border:1px solid transparent; border-radius:999px; padding:4px 10px;
  }
  /* Split the six color chips into 2 lines (3 × 2) and keep Search below */
.colors{
  display: grid;
  grid-template-columns: repeat(3, max-content); /* 3 per row */
  gap: 8px 10px;
  flex: 1 1 100%; /* take full line so the Search button wraps to next line */
}

/* Smaller screens: 2 per row */
@media (max-width: 520px){
  .colors{ grid-template-columns: repeat(2, max-content); }
}

/* Align the row so multi-line chips don’t collide with neighbors */
.row{ align-items: flex-start; }
  
/* Make sure hover also respects rounding */
.btn:hover { border-radius: 12px; }
</style>

</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">🧰 MTG Collection Browser</div>
      <div class="muted">Local-first • Works offline • Zero backend</div>
    </header>

    <div class="bar" style="margin-bottom:12px">
      <button class="btn" id="btnUpdateDB" title="Force reindex now (Alt-click for full rebuild)">Update database</button>
      <button class="btn" id="btnExport">⬇️ Export Collection (JSON)</button>
      <label class="btn file">⬆️ Import Collection (JSON)
        <input id="importCollection" type="file" accept=".json" />
      </label>
      <label class="btn file">📄 Add Cards (CSV)
        <input id="importCSV" type="file" accept=".csv" />
      </label>

      <label class="btn file">📝 Add Cards (TXT)
        <input id="importTXT" type="file" accept=".txt" />
      </label>
      <label class="btn" style="display:flex;align-items:center;gap:8px">
        <input id="csvStrict" type="checkbox" /> Strict set match
      </label>
      <button class="btn danger" id="btnClearDB" title="Delete all cards from the local database">🗑️ Clear Card DB</button>
      <button class="btn danger" id="btnClearCollection" title="Clear only your collection quantities">🧹 Clear Collection</button>
      <div class="muted small">Tip: Best results from <span class="kbd">MTG Scanner — Dragon Shield</span> CSV export or <span class="kbd">TCGplayer Scanner</span> TXT share file.</div>
    </div>

    <div class="grid">
      <section class="panel details">
        <div class="head"><strong>Search</strong></div>
        <div class="body">
          <div class="row" style="margin-bottom:8px">
            <input id="qName" type="text" placeholder="Name contains… (supports ^prefix and suffix$)" />
          </div>
          <div class="row" style="margin-bottom:8px">
            <input id="qText" type="text" placeholder="Oracle text contains… (e.g., double strike)" />
          </div>
          <div class="row" style="margin-bottom:8px">
            <select id="qType">
              <option value="">Any Type</option>
              <option>Creature</option>
              <option>Instant</option>
              <option>Sorcery</option>
              <option>Artifact</option>
              <option>Enchantment</option>
              <option>Planeswalker</option>
              <option>Land</option>
            </select>
            <select id="qRarity">
              <option value="">Any Rarity</option>
              <option>common</option>
              <option>uncommon</option>
              <option>rare</option>
              <option>mythic</option>
            </select>
            <input id="qSubtype" type="text" placeholder="Subtype (e.g., Sliver)" />
          </div>
          <div class="row" style="margin-bottom:8px">
            <div class="colors">
              <label class="chip"><input type="checkbox" class="ci" value="W"> <span class="dot W"></span> W</label>
              <label class="chip"><input type="checkbox" class="ci" value="U"> <span class="dot U"></span> U</label>
              <label class="chip"><input type="checkbox" class="ci" value="B"> <span class="dot B"></span> B</label>
              <label class="chip"><input type="checkbox" class="ci" value="R"> <span class="dot R"></span> R</label>
              <label class="chip"><input type="checkbox" class="ci" value="G"> <span class="dot G"></span> G</label>
              <label class="chip"><input type="checkbox" class="ci" value="C"> <span class="dot C"></span> C</label>
            </div>
            <button class="btn" id="btnSearch">Search</button>
          </div>
          <div class="muted small" id="dbStats">DB: — cards • Collection: — entries</div>
        </div>
      </section>

      <section class="panel">
        <div class="head">
          <strong>Results</strong>
          <div class="muted small" id="status">Ready.</div>
        </div>
        <div class="body">
          <div id="importBox" class="muted small" style="display:none; margin-bottom:12px">
            <div>Importing… <progress id="importProgress" max="100" value="0"></progress></div>
            <div id="importNote" class="muted small"></div>
          </div>
          <div id="csvBox" class="muted small" style="display:none; margin-bottom:12px">
            <div>Importing CSV… <progress id="csvProgress" max="100" value="0"></progress></div>
            <div id="csvNote" class="muted small"></div>
          </div>

          <div id="resolveBox" class="panel" style="display:none; margin-bottom:12px">
            <div class="head">
              <strong>Resolve Unmatched Import Rows</strong>
              <div class="row" style="gap:8px;align-items:center">
                <div class="muted small" id="resolveStats">0 unresolved</div>
                <button class="btn" id="resolveClear" title="Hide this panel">Clear All</button>
              </div>
            </div>
            <div class="body">
              <div class="muted small" style="margin-bottom:8px">
                If a printing exists on <strong>PLST — The List</strong>, we auto-select it and don’t show a row.
              </div>
              <div id="resolveList" class="small"></div>
            </div>
          </div>

          <div id="results" class="results"></div>
        </div>
      </section>
    </div>
  </div>

<script>
/* -------------------- IndexedDB (Dexie) -------------------- */
const db = new Dexie('mtgDB');
db.version(1).stores({
  cards: 'id, name, name_lc, rarity, set, set_name, type_lc, subtype_lc, *color_identity, collector_number',
  collection: 'id, qty'
});

/* -------------------- Element refs -------------------- */
const els = {
  btnUpdateDB: document.getElementById('btnUpdateDB'),
  importBox: document.getElementById('importBox'),
  importProgress: document.getElementById('importProgress'),
  importNote: document.getElementById('importNote'),
  status: document.getElementById('status'),
  results: document.getElementById('results'),
  qName: document.getElementById('qName'),
  qText: document.getElementById('qText'),
  qType: document.getElementById('qType'),
  qSubtype: document.getElementById('qSubtype'),
  qRarity: document.getElementById('qRarity'),
  btnSearch: document.getElementById('btnSearch'),
  dbStats: document.getElementById('dbStats'),
  btnExport: document.getElementById('btnExport'),
  importCollection: document.getElementById('importCollection'),
  importCSV: document.getElementById('importCSV'),
  importTXT: document.getElementById('importTXT'),
  csvBox: document.getElementById('csvBox'),
  csvProgress: document.getElementById('csvProgress'),
  csvNote: document.getElementById('csvNote'),
  csvStrict: document.getElementById('csvStrict'),
  btnClearDB: document.getElementById('btnClearDB'),
  btnClearCollection: document.getElementById('btnClearCollection'),
  resolveBox: document.getElementById('resolveBox'),
  resolveList: document.getElementById('resolveList'),
  resolveStats: document.getElementById('resolveStats'),
  resolveClear: document.getElementById('resolveClear'),
    // NEW: for the mobile collapse/expand behavior
  searchPanel: document.querySelector('section.panel.details'),
  searchHead:  document.querySelector('section.panel.details .head'),
};

/* ---------- utils ---------- */
const fmt   = (n) => (typeof n === 'number' ? n.toLocaleString() : n);
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
let suppressAutoUntil = 0; // ms timestamp: ignore auto-collapse until this time
let lastTouchToggleAt = 0; 
const MOBILE_BP = 900;
const COLLAPSE_THRESHOLD = 250; // tweak feel here

const faceIndex = {};  // id -> 0/1/...

window.loadComboPieces = async function(cardId){
  const card = window.__cardsById[cardId];
  const pop = document.getElementById(`combo-pop-${cardId}`);
  if (!card || !pop || pop.dataset.loaded === '1') return;

  const refs = (card.combo_refs || []);
  if (!refs.length){
    pop.innerHTML = `<div class="combo-title">No additional pieces listed.</div>`;
    pop.dataset.loaded = '1';
    return;
  }

  // Try exact by id; if missing, fall back by name (oracle dataset can differ)
  const ids = refs.map(r => r.id).filter(Boolean);
  let cards = ids.length ? await db.cards.bulkGet(ids) : [];
  const results = [];

  for (let i = 0; i < refs.length; i++){
    let c = cards[i];
    const ref = refs[i];
    if (!c && ref.name){
      c = await db.cards.where('name_lc').equals(ref.name.toLowerCase()).first();
    }
    if (c) results.push({ ref, card: c });
  }

  // Collection ownership tags
  const owned = {};
  const collRows = await db.collection.toArray();
  for (const r of collRows) owned[r.id] = r.qty || 0;

  const tiles = results.map(({card: rc}) => {
    const have = owned[rc.id] > 0;
    const tag  = have
      ? `<div class="combo-owned">Owned ×${owned[rc.id]}</div>`
      : `<div class="combo-miss">Not owned</div>`;
    const img  = rc.image || rc.card_faces?.[0]?.image || '';
    return `
      <a class="combo-item" href="${rc.scryfall_uri || '#'}" target="_blank" title="${rc.name}">
        ${tag}
        <img loading="lazy" src="${img}" alt="${rc.name}">
      </a>`;
  }).join('');

  pop.innerHTML = `
    <div class="combo-title">Combo Pieces</div>
    <div class="combo-grid">${tiles || '<div class="muted small">No matching pieces found locally.</div>'}</div>
  `;
  pop.dataset.loaded = '1';
};
  
function flipCard(id){
  const card = window.__cardsById[id];
  if (!card || !Array.isArray(card.faces) || card.faces.length < 2) return;
  const i = (faceIndex[id] || 0);
  const next = (i + 1) % card.faces.length;
  faceIndex[id] = next;

  const f = card.faces[next];
  const img = document.getElementById(`img-${card.id}`);
  if (img) img.src = f.image || card.image || '';

  const nameEl = document.getElementById(`title-${card.id}`);
  if (nameEl) nameEl.textContent = f.name || card.name;

  const typeEl = document.getElementById(`type-${card.id}`);
  if (typeEl) typeEl.textContent = f.type_line || card.type_line;

  const manaEl = document.getElementById(`mc-${card.id}`);
  if (manaEl){ const mc = f.mana_cost || ''; manaEl.style.display = mc ? '' : 'none'; manaEl.textContent = mc; }

  const ptEl = document.getElementById(`pt-${card.id}`);
  if (ptEl){
    const text = (f.power || f.toughness) ? `${f.power ?? ''}/${f.toughness ?? ''}` :
                 (f.loyalty ? `Loyalty ${f.loyalty}` : '');
    ptEl.style.display = text ? '' : 'none';
    ptEl.textContent = text;
  }

  const rulesEl = document.getElementById(`rules-${card.id}`);
  if (rulesEl){
    rulesEl.innerHTML = (f.oracle_text || '').replaceAll('{','<span class=chip>{').replaceAll('}','}</span>');
  }
}



function isMobile(){ return window.innerWidth <= MOBILE_BP; }
function setSearchExpanded(expanded){
  if (!els.searchPanel || !els.searchHead) return;
  els.searchPanel.classList.toggle('collapsed', !expanded);
  els.searchHead.setAttribute('aria-expanded', expanded ? 'true' : 'false');
}
function expandSearch(){ setSearchExpanded(true); }
function collapseSearch(){ setSearchExpanded(false); }
function userToggleSearch(){
  if (!isMobile()) return;
  const isCollapsed = els.searchPanel.classList.contains('collapsed');
  setSearchExpanded(!isCollapsed);
  suppressAutoUntil = Date.now() + 800; // grace so scroll handler won't fight it
}
function onScrollCollapse(){
  if (!isMobile()){ expandSearch(); return; }
  if (Date.now() < suppressAutoUntil) return;  // don't fight user tap
  const y = window.scrollY || document.documentElement.scrollTop || 0;
  const shouldCollapse = y > COLLAPSE_THRESHOLD;
  setSearchExpanded(!shouldCollapse);
}

// listeners
window.addEventListener('scroll', onScrollCollapse, { passive:true });
window.addEventListener('resize', onScrollCollapse);

// initialize state right away on load (no need to click first)
onScrollCollapse();


// Desktop / fallback click
els.searchHead.addEventListener('click', () => {
  if (window.innerWidth > 900) return;
  const isCollapsed = els.searchPanel.classList.contains('collapsed');
  els.searchPanel.classList.toggle('collapsed', !isCollapsed);
  suppressAutoUntil = Date.now() + 800; // so the scroll listener won't immediately re-collapse
});

// focusing any input expands it
els.searchPanel.querySelectorAll('input, select').forEach(el => {
  el.addEventListener('focus', expandSearch);
});

// after pressing Search on mobile, collapse back
els.btnSearch.addEventListener('click', () => { if (isMobile()) collapseSearch(); });

// initialize correct state on load
window.addEventListener('DOMContentLoaded', onScrollCollapse);

  

/* ---------- repo base + data URL ---------- */
// For GitHub Project Pages: repo root is the first path segment.
function repoBase() {
  const parts = location.pathname.split('/').filter(Boolean);
  return parts.length ? `/${parts[0]}/` : '/';
}
// Always fetch from /db/ at the repo root
const NDJSON_URL = `${repoBase()}db/cards.ndjson.gz`;

/* ---------- HEAD/ETag helpers ---------- */
function headKey(url){ return `ndjson_head::${url}`; }
async function getRemoteHead(url){
  const resp = await fetch(url, { method:'HEAD', cache:'no-store' });
  if (!resp.ok && resp.status !== 304) throw new Error(`HEAD ${resp.status} ${resp.statusText}`);
  return {
    etag: resp.headers.get('etag') || '',
    last: resp.headers.get('last-modified') || '',
    len:  resp.headers.get('content-length') || ''
  };
}
function saveHeadMeta(url, meta){ try { localStorage.setItem(headKey(url), JSON.stringify(meta)); } catch{} }
function loadHeadMeta(url){ try { return JSON.parse(localStorage.getItem(headKey(url)) || 'null'); } catch { return null; } }
async function isRemoteUnchanged(url){
  const remote = await getRemoteHead(url);
  const prev = loadHeadMeta(url);
  if (!prev) return false;
  if (remote.etag && prev.etag) return remote.etag === prev.etag;
  if (remote.last && prev.last) return remote.last === prev.last;
  return false;
}

/* ---------- streaming gunzip ---------- */
function gunzipStream(compressedStream){
  if ('DecompressionStream' in window) {
    return compressedStream.pipeThrough(new DecompressionStream('gzip'));
  }
  if (!window.fflate) throw new Error('No gzip support (fflate missing)');
  const reader = compressedStream.getReader();
  const gunzip = new fflate.AsyncGunzip();
  return new ReadableStream({
    start(controller){
      gunzip.ondata = (chunk, final) => {
        controller.enqueue(chunk);
        if (final) controller.close();
      };
      gunzip.onerror = (err) => controller.error(err);
      (async function pump(){
        for(;;){
          const {value, done} = await reader.read();
          if (done){ gunzip.flush(); break; }
          gunzip.push(value);
        }
      })();
    },
    cancel(reason){ try { reader.cancel(reason); } catch{} }
  });
}

/* ---------- importer (fixed stream + no long tx) ---------- */
async function importNDJSONFromURL(url = NDJSON_URL, { skipIfUnchanged = true } = {}) {
  els.importBox.style.display = '';
  els.importProgress.value = 0;
  els.importNote.textContent = `Fetching ${url} …`;

  // HEAD/ETag early-out
  if (skipIfUnchanged) {
    try {
      const skip = await isRemoteUnchanged(url);
      const count = await db.cards.count();
      if (skip && count > 0) {
        els.importProgress.value = 100;
        els.importNote.textContent = 'Remote file unchanged; skipped re-index.';
        els.status.textContent = 'Remote unchanged; using existing DB';
        hideStatusBars();
        return;
      }
    } catch (e) { console.warn('HEAD check failed; continuing:', e); }
  }

  // Save HEAD metadata for next time (best effort)
  let headMeta = null;
  try { headMeta = await getRemoteHead(url); } catch {}

  // Fetch
  const resp = await fetch(url, { cache:'no-store' });
  if (!resp.ok) throw new Error(`Fetch failed: ${resp.status} ${resp.statusText}`);
  if (!resp.body) throw new Error('No response body stream');

  // Decide if gzipped
  const ct  = resp.headers.get('content-type') || '';
  const enc = resp.headers.get('content-encoding') || '';
  const looksGzip = /\.gz($|\?)/i.test(url) || /gzip/i.test(ct) || /gzip/i.test(enc);

  // BYTES stream -> (optional) gunzip -> TEXT stream
  let stream = resp.body;                         // <— define stream
  if (looksGzip) stream = gunzipStream(stream);
  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();

  // Parse NDJSON lines, flush in small batches (no long transaction)
  const CHUNK = 200;
  let leftover = '';
  let batch = [];
  let inserted = 0;

  els.status.textContent = 'Indexing remote cards…';

  for (;;) {
    const { value, done } = await reader.read();
    if (done) break;
    leftover += value;

    let nl;
    while ((nl = leftover.indexOf('\n')) >= 0) {
      const line = leftover.slice(0, nl).trim();
      leftover = leftover.slice(nl + 1);
      if (!line) continue;
      try {
        const raw = JSON.parse(line);
        batch.push(normalizeCard(raw));
      } catch { /* ignore malformed line */ }

      if (batch.length >= CHUNK) {
        await db.cards.bulkPut(batch);           // short implicit tx
        inserted += batch.length;
        batch.length = 0;

        els.importProgress.value = Math.min(100, Math.round(inserted / 5000 * 100));
        els.importNote.textContent = `Indexed ${inserted.toLocaleString()} cards…`;
        await new Promise(requestAnimationFrame);
      }
    }
  }

  if (leftover.trim()) {
    try { batch.push(normalizeCard(JSON.parse(leftover.trim()))); } catch {}
  }
  if (batch.length) { await db.cards.bulkPut(batch); inserted += batch.length; }

  els.importProgress.value = 100;
  els.importNote.textContent = `Done. Indexed ${inserted.toLocaleString()} cards from URL.`;
  els.status.textContent = 'Remote import complete';
  await refreshStats();
  if (headMeta) saveHeadMeta(url, headMeta);
  hideStatusBars();
}

/* ---------- auto import on load ---------- */
window.addEventListener('DOMContentLoaded', async () => {
  try { await importNDJSONFromURL(NDJSON_URL, { skipIfUnchanged:true }); }
  catch (e) {
    console.error(e);
    els.status.textContent = 'Remote import failed.';
    els.importNote.textContent = `Error: ${e?.message || e}`;
  }
});

/* ---------- update button ---------- */
els.btnUpdateDB.addEventListener('click', async (e) => {
  const fullRebuild = e.altKey;
  const msg = fullRebuild
    ? 'This will CLEAR the local card database, then re-download and re-index.\nYour collection quantities are kept.\nProceed?'
    : 'Re-index from the remote NDJSON now? (Skips HEAD check.)';
  if (!confirm(msg)) return;
  try {
    if (fullRebuild) { await db.cards.clear(); await refreshStats(); }
    await importNDJSONFromURL(NDJSON_URL, { skipIfUnchanged:false });
    els.status.textContent = 'Update complete.';
    await refreshStats();
    try { await search(); } catch {}
  } catch (err) {
    console.error(err);
    els.status.textContent = 'Update failed.';
    els.importNote.textContent = `Error: ${err?.message || err}`;
    alert('Update failed.');
  }
});

/* -------------------- CSV utils + parser -------------------- */
function stripSepAndBOM(text){
  if (!text) return text;
  if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  const e = text.indexOf('\n');
  const firstLine = e >= 0 ? text.slice(0, e).trim() : text.trim();
  if (/^sep\s*=\s*./i.test(firstLine)) text = e >= 0 ? text.slice(e+1) : '';
  return text;
}

function parseScannerTXT(text){
  // Returns [{ row, name, qty, setCode:'', setName:'' }, ...]
  const out = [];
  const lines = text.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++){
    const line = lines[i].trim();
    if (!line) continue;
    if (/^total:/i.test(line)) continue;                 // header
    if (/^prices from/i.test(line)) continue;            // footer

    // e.g. "2 Scour for Scrap [Edge] (Normal, Near Mint, English) - $0.42 ($0.21 ea)"
    // e.g. "1 Eldrazi Temple (0014) (Borderless) [Edge] (Normal...) - $2.53"
    const m = line.match(/^\s*(\d+)\s+(.+?)(?:\s*\[(.*?)\])?(?:\s*\(.*?\))?\s*-\s*\$/);
    if (!m) continue;

    const qty = parseInt(m[1], 10);
    let name  = (m[2] || '').trim();
    const bracket = (m[3] || '').trim();  // often "Edge", "Commander", etc.

    // Skip obvious tokens (the file has "Doubled-Sided Token", etc.)
    if (/token/i.test(name)) continue;

    // Normalize weird spacing
    name = name.replace(/\s+/g,' ').trim();

    out.push({
      row: i + 1,
      name,
      qty: isFinite(qty) ? qty : 0,
      setCode: '',             // this format rarely has actual codes
      setName: bracket || ''   // try to use bracket as set name when present
    });
  }
  return out;
}

function hideStatusBars(delay=800){
  setTimeout(() => {
    els.importBox.style.display = 'none';
    els.csvBox.style.display = 'none';
  }, delay);
}
  
function parseCSV(text){
  text = stripSepAndBOM(text);
  const rows=[]; let row=[], field='', inQ=false;
  for (let i=0;i<text.length;i++){
    const c=text[i];
    if (inQ){
      if (c === '"'){ if (text[i+1] === '"'){ field+='"'; i++; } else { inQ=false; } }
      else field+=c;
    }else{
      if (c === '"') inQ=true;
      else if (c === ','){ row.push(field); field=''; }
      else if (c === '\n'){ row.push(field); rows.push(row); row=[]; field=''; }
      else if (c === '\r'){ }
      else field+=c;
    }
  }
  row.push(field);
  if (row.length && (row.length>1 || row[0]!=='')) rows.push(row);
  return rows;
}

/* -------------------- Card helpers -------------------- */
function normalizeCard(raw){
  const faces = Array.isArray(raw.card_faces) ? raw.card_faces.map(f => ({
    name: f.name || '',
    mana_cost: f.mana_cost || '',
    type_line: f.type_line || '',
    oracle_text: f.oracle_text || '',
    colors: f.colors || [],
    power: f.power ?? null,
    toughness: f.toughness ?? null,
    loyalty: f.loyalty ?? null,
    image: f.image_uris?.normal || null
  })) : null;

  const img = raw.image_uris?.normal || faces?.[0]?.image || null;
  const oracle_text = raw.oracle_text || (faces?.map(f=>f.oracle_text).filter(Boolean).join('\n')) || '';
  const mana_cost = raw.mana_cost || (faces?.map(f=>f.mana_cost).filter(Boolean).join(' // ')) || '';
  const type_line = raw.type_line || (faces?.map(f=>f.type_line).join(' // ')) || '';

  const is_dfc = !!(faces && faces.length >= 2);

  const { name, id, set, set_name, rarity, color_identity = [] } = raw;
  const subtype = (type_line.split('—')[1] || '').trim();
  const combo_refs = (raw.all_parts || [])
    .filter(p =>
      p.component === 'combo_piece' &&
      !/token|emblem/i.test(p.type_line || '') &&
      p.id !== raw.id
    )
    .map(p => ({ id: p.id, name: p.name || '' }));
  
  return {
    id, name, name_lc: name.toLowerCase(),
    set, set_name: set_name || '',
    rarity: rarity || '',
    image: img, oracle_text, mana_cost,
    cmc: raw.cmc ?? null,
    type_line,
    type_lc: type_line.toLowerCase(),
    subtype_lc: subtype.toLowerCase(),
    colors: raw.colors || [],
    color_identity,
    power: raw.power ?? faces?.[0]?.power ?? null,
    toughness: raw.toughness ?? faces?.[0]?.toughness ?? null,
    loyalty: raw.loyalty ?? faces?.[0]?.loyalty ?? null,
    collector_number: raw.collector_number || '',
    purchase_uris: raw.purchase_uris || {},
    scryfall_uri: raw.scryfall_uri || '',
    prices: raw.prices || {},
    faces,                     // <— new
    is_dfc,                    // <— new
    all_parts: raw.all_parts || [],
    combo_refs,   
    layout: raw.layout || ''   // <— handy if you want to style by layout
  };
}

function cardKingdomURL(card){
  const name = encodeURIComponent(card.name);
  const set  = encodeURIComponent(card.set_name || '');
  return `https://www.cardkingdom.com/catalog/search?search=mtg_advanced&name=${name}&filter%5Bedition%5D=${set}`;
}

function money(v){
  const n = Number(v);
  return Number.isFinite(n) ? `$${n.toFixed(2)}` : '';
}
// prefer non-foil USD, fall back to foil/etched if needed
function usdPrice(card){
  const p = card?.prices || {};
  return money(p.usd || p.usd_foil || p.usd_etched || '');
}
function slugifyForEdhrec(s){
  return s.toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // strip accents
    .replace(/[^a-z0-9]+/g,'-')                     // spaces & punctuation → -
    .replace(/^-+|-+$/g,'');                        // trim dashes
}
function edhrecURL(card){
  return `https://edhrec.com/cards/${slugifyForEdhrec(card.name)}`;
}

function isDoubleFaced(card){
  return (Array.isArray(card.faces) && card.faces.length >= 2) ||
         ['transform','modal_dfc','meld','flip','double_faced_token'].includes(card.layout);
}
  
function renderCardCard(card, qty=0) {
  const colors = (card.color_identity?.length ? card.color_identity : ['C'])
    .map(c => `<span class="dot ${c}" title="${c}"></span>`).join('');
  const isDFC = isDoubleFaced(card);
  const firstFace = card.faces?.[0];
  const ptText = (firstFace?.power || firstFace?.toughness)
      ? `${firstFace.power ?? ''}/${firstFace.toughness ?? ''}`
      : (firstFace?.loyalty ? `Loyalty ${firstFace.loyalty}` : '');
  const mcText = firstFace?.mana_cost || card.mana_cost || '';

  return `
    <div class="card">
      <img id="img-${card.id}" loading="lazy" alt="${card.name}"
           src="${(firstFace?.image || card.image) || ''}"
           onerror="this.src=''; this.style.background='#0b0d0f'">
      <div class="meta">
        <div class="line">
          <strong id="title-${card.id}">${firstFace?.name || card.name}</strong>
          <span class="colors">${colors}</span>
          ${card.rarity ? `<span class="chip">${card.rarity}</span>` : ''}
        </div>
        <div class="line">
          <div class="qty">
            <button class="btn ghost" onclick="addToCollection('${card.id}', -1)">−</button>
            <input class="qty-in" id="qty-${card.id}" value="${qty}" readonly>
            <button class="btn ghost" onclick="addToCollection('${card.id}', 1)">＋</button>
          </div>
        </div>

        <div class="row" style="justify-content:space-between; flex-wrap:wrap">
          <div class="row">
            <a class="btn" href="${card.scryfall_uri}" target="_blank">Scryfall</a>
            ${card.purchase_uris?.tcgplayer ? `<a class="btn" href="${card.purchase_uris.tcgplayer}" target="_blank">TCGplayer</a>` : ''}
            <a class="btn" href="${cardKingdomURL(card)}" target="_blank">Card Kingdom</a>
            <a class="btn" href="${edhrecURL(card)}" target="_blank">EDHREC</a>
          </div>
          ${isDFC ? `<button class="btn" onclick="flipCard('${card.id}')">Flip</button>` : ''}
          ${(card.combo_refs && card.combo_refs.length)
            ? `
            <div class="combo-wrap">
              <button class="btn combo-chip"
                      onmouseenter="loadComboPieces('${card.id}')"
                      ontouchstart="loadComboPieces('${card.id}')">
                ✨ Combo Pieces
              </button>
              <div class="combo-pop" id="combo-pop-${card.id}" data-loaded="0">
                <div class="muted small">Loading…</div>
              </div>
            </div>`
            : ''
          }
        </div>
      </div>
    </div>`;
}


/* Temp page helpers */
window.__cardsById = {};
function buildTempPageHTML(card){
  const colors = (card.color_identity?.length ? card.color_identity : ['C']).map(c=>`<span class="dot ${c}"></span>`).join('');
  const pt = card.power || card.toughness ? `${card.power ?? ''}/${card.toughness ?? ''}` : (card.loyalty ? `Loyalty ${card.loyalty}` : '');
  const tcg = card.purchase_uris?.tcgplayer ? `<a class="btn" href="${card.purchase_uris.tcgplayer}" target="_blank">TCGplayer</a>` : '';
  const ck = `<a class="btn" href="${cardKingdomURL(card)}" target="_blank">Card Kingdom</a>`;
  return `<!doctype html>
<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${card.name} — Deck View</title>
<style>
  body{margin:0;background:#0b0d0f;color:#e8edf2;font-family:system-ui,Segoe UI,Roboto,Inter,Arial}
  .wrap{max-width:1000px;margin:0 auto;padding:18px}
  .grid{display:grid;grid-template-columns:360px 1fr;gap:16px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .panel{background:#12161a;border:1px solid #24303a;border-radius:14px;overflow:hidden}
  .img{background:#0d1117;display:block}
  img{width:100%;display:block;aspect-ratio:3/4;object-fit:contain}
  .body{padding:14px 16px}
  .chips{display:flex;gap:8px;flex-wrap:wrap}
  .chip{background:#222a32;border:1px solid #24303a;padding:4px 8px;border-radius:999px;font-size:12px}
  .dot{width:12px;height:12px;border-radius:999px;border:1px solid #0006;display:inline-block;margin-right:6px}
  .W{background:#f9f5d7}.U{background:#79a6ff}.B{background:#5c5c5c}.R{background:#ff8f8f}.G{background:#67c77a}.C{background:#cbd5e1}
  .btn{background:#171c22;border:1px solid #24303a;color:#e8edf2;padding:8px 12px;border-radius:10px;text-decoration:none}
  .btn:hover{border-color:#6ee7ff}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  pre{white-space:pre-wrap}
</style></head>
<body><div class="wrap">
  <h2 style="margin:0 0 12px 0">${card.name}</h2>
  <div class="grid">
    <div class="panel img">${card.image ? `<img alt="${card.name}" src="${card.image}">` : ''}</div>
    <div class="panel"><div class="body">
      <div class="row" style="justify-content:space-between">
        <div class="chips">${colors}</div>
        <div class="chip">${card.rarity || ''}</div>
      </div>
      <div class="chip" style="margin-top:10px">${card.type_line || ''}</div>
      ${card.mana_cost ? `<div class="chip" style="margin-top:10px">${card.mana_cost}</div>`:''}
      ${pt ? `<div class="chip" style="margin-top:10px">${pt}</div>`:''}
      <h3 style="margin-top:18px">Text</h3>
      <pre>${(card.oracle_text||'')}</pre>
      <div class="row" style="margin-top:14px"><a class="btn" href="${card.scryfall_uri}" target="_blank">Scryfall</a>${tcg}${ck}</div>
      <div style="margin-top:8px;color:#9aa4ad;font-size:12px">${card.set_name || ''} ${card.collector_number ? `• #${card.collector_number}` : ''}</div>
    </div></div>
  </div>
</div></body></html>`;
}
function openTempPageById(id){
  const card = window.__cardsById[id];
  if (!card) return;
  const w = window.open('about:blank','_blank');
  w.document.open('text/html','replace');
  w.document.write(buildTempPageHTML(card));
  w.document.close();
}

/* Stats + collection helpers */
async function refreshStats(){
  const cardCount = await db.cards.count();
  const collCount = await db.collection.count();
  els.dbStats.textContent = `DB: ${fmt(cardCount)} cards • Collection: ${fmt(collCount)} entries`;
}
async function addToCollection(id, delta){
  const cur = await db.collection.get(id) || { id, qty: 0 };
  cur.qty = Math.max(0, (cur.qty || 0) + delta);
  if (cur.qty === 0) await db.collection.delete(id); else await db.collection.put(cur);
  const input = document.getElementById('qty-'+id);
  if (input) input.value = cur.qty;
  refreshStats();
}
window.addToCollection = addToCollection;

/* -------------------- Filtering helpers -------------------- */
function colorsMatch(cardCI, selectedColors){
  if (!selectedColors || selectedColors.length === 0) return true;
  const sel = new Set(selectedColors);
  const includeC = sel.has('C');
  sel.delete('C');
  const ci = Array.isArray(cardCI) ? cardCI : [];
  if (ci.length === 0) return includeC;
  if (sel.size === 0) return false;
  for (const c of ci) if (!sel.has(c)) return false;
  return true;
}
function matchCard(card, f){
  const name_lc = (card.name_lc||'');
  const type_lc = (card.type_lc||'');
  const subtype_lc = (card.subtype_lc||'');
  const oracle_lc = (card.oracle_text||'').toLowerCase();
  if (f.name) {
    const q = f.name;

    // Allow ^prefix or suffix$ power users
    if (q.startsWith('^')) {
      if (!name_lc.startsWith(q.slice(1))) return false;
    } else if (q.endsWith('$')) {
      if (!name_lc.endsWith(q.slice(0, -1))) return false;
    } else {
      // Default: every term must appear somewhere in the name
      const terms = q.split(/\s+/).filter(Boolean);
      for (const t of terms) {
        if (!name_lc.includes(t)) return false;
      }
    }
  }
  if (f.type && !type_lc.includes(f.type.toLowerCase())) return false;
  if (f.subtype && !subtype_lc.includes(f.subtype)) return false;
  if (f.rarity && card.rarity !== f.rarity) return false;
  if (f.text && !oracle_lc.includes(f.text)) return false;
  if (!colorsMatch(card.color_identity, f.colors)) return false;
  return true;
}

/* -------------------- Search (collection-only) -------------------- */
async function search(){
  const filters = {
    name: els.qName.value.trim().toLowerCase(),
    text: els.qText.value.trim().toLowerCase(),
    type: els.qType.value,
    subtype: els.qSubtype.value.trim().toLowerCase(),
    rarity: els.qRarity.value,
    colors: Array.from(document.querySelectorAll('.ci:checked')).map(c=>c.value)
  };
  els.status.textContent = 'Searching your collection…';

  const owned = await db.collection.where('qty').above(0).toArray();
  const qtyMap = Object.fromEntries(owned.map(e=>[e.id, e.qty]));
  if (!owned.length){
    els.results.innerHTML = '';
    els.status.textContent = 'Your collection is empty — import CSV to add cards.';
    return;
  }
  const ids = owned.map(e=>e.id);
  const cards = await db.cards.bulkGet(ids);

  const limit = 200;
  const out = [];
  for (const card of cards){
    if (!card) continue;
    if (matchCard(card, filters)){
      out.push(card);
      if (out.length >= limit) break;
    }
  }
  els.results.innerHTML = out.map(c => { window.__cardsById[c.id] = c; return renderCardCard(c, qtyMap[c.id]||0); }).join('');
  els.status.textContent = `Showing ${out.length} result(s) from your collection`;
}
els.btnSearch.addEventListener('click', search);
['qName','qText','qType','qSubtype','qRarity'].forEach(id => document.getElementById(id).addEventListener('keydown', e => { if (e.key === 'Enter') search(); }));
document.querySelectorAll('.ci').forEach(el => el.addEventListener('change', search));

/* -------------------- Export/Import collection (JSON) -------------------- */
els.btnExport.addEventListener('click', async () => {
  const all = await db.collection.toArray();
  const blob = new Blob([JSON.stringify({ exported_at: new Date().toISOString(), entries: all }, null, 2)], { type: 'application/json' });
  const a = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: 'mtg-collection.json' });
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
});
els.importCollection.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  const text = await file.text();
  try{
    const data = JSON.parse(text);
    const entries = Array.isArray(data) ? data : (data.entries || []);
    await db.collection.clear();
    await db.collection.bulkPut(entries);
    await refreshStats();
    els.status.textContent = `Imported ${fmt(entries.length)} collection entries.`;
  }catch{ alert('Could not parse collection JSON'); }
  e.target.value='';
});

/* -------------------- CSV helpers + unmatched resolver -------------------- */
// Known TCGplayer export header (order matters)
const DEFAULT_TCGPLAYER_HEADER = [
  "Folder Name","Quantity","Trade Quantity","Card Name","Set Code","Set Name",
  "Card Number","Condition","Printing","Language","Price Bought","Date Bought",
  "LOW","MID","MARKET"
];

/**
 * If the file starts with:
 *  - "sep=,"  → skip 2 lines (the sep line + the header line) and provide a known header
 *  - "Folder Name" → skip 1 line (the header) and provide a known header
 * Otherwise, keep content as-is and let the first parsed row be the header.
 */
function peelCsvHeader(rawText){
  // strip BOM if present
  if (rawText && rawText.charCodeAt(0) === 0xFEFF) rawText = rawText.slice(1);

  const nl1 = rawText.indexOf('\n');
  const firstLine = (nl1 >= 0 ? rawText.slice(0, nl1) : rawText).trim();

  // Case 1: starts with sep=
  if (/^\s*"?\s*sep\s*=\s*,\s*"?\s*$/i.test(firstLine)) {
    // skip sep line and the next line (header line)
    const start2 = nl1 >= 0 ? nl1 + 1 : rawText.length;
    const nl2 = rawText.indexOf('\n', start2);
    const csvText = (nl2 >= 0 ? rawText.slice(nl2 + 1) : '');
    return { csvText, header: DEFAULT_TCGPLAYER_HEADER };
  }

  // Case 2: first line is the header (starts with “Folder Name”)
  if (/^Folder Name\b/i.test(firstLine)) {
    const csvText = (nl1 >= 0 ? rawText.slice(nl1 + 1) : '');
    return { csvText, header: DEFAULT_TCGPLAYER_HEADER };
  }

  // Otherwise: keep as-is; first parsed row will be the header
  return { csvText: rawText, header: null };
}

  
function selectCardByNameAndSet(candidates, setCode, setName, strict){
  // If your DB guarantees 1 print per card, just return it.
  if (candidates.length === 1) return candidates[0];

  let card = null;
  if (setCode){
    const sc = setCode.toLowerCase();
    card = candidates.find(c => (c.set||'').toLowerCase() === sc) || null;
    if (!card && strict) return null;
  }
  if (!card && setName){
    const sn = setName.toLowerCase();
    card = candidates.find(c => (c.set_name||'').toLowerCase() === sn) || null;
    if (!card && strict && (setCode || setName)) return null;
  }
  if (!card) card = candidates[0] || null;   // fall back to first
  return card;
}
let __unmatchedRows = [];
els.resolveClear.addEventListener('click', () => {
  els.resolveBox.style.display = 'none';
  els.resolveList.innerHTML = '';
  els.resolveStats.textContent = '0 unresolved';
  __unmatchedRows = [];
});
function tokenizeName(s){ return (s||'').toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/).filter(Boolean); }
function tokenMatchRatio(aName, bName){
  const a = tokenizeName(aName);
  const bSet = new Set(tokenizeName(bName));
  if (!a.length) return 0;
  let hit=0; for (const t of a){ if (bSet.has(t)) hit++; }
  return hit/a.length;
}
async function renderResolveUnmatched(list){
  __unmatchedRows = list.map(x => ({...x, resolved:false}));
  if (!__unmatchedRows.length){
    els.resolveBox.style.display = 'none';
    els.resolveList.innerHTML = '';
    els.resolveStats.textContent = '0 unresolved';
    return;
  }
  els.resolveBox.style.display = '';
  els.resolveList.innerHTML = '';
  updateResolveStats();

  for (const item of __unmatchedRows){
    const nameLC = item.name.toLowerCase();
    let candidates = await db.cards.where('name_lc').equals(nameLC).toArray();
    if (!candidates.length) candidates = await db.cards.where('name_lc').startsWith(nameLC).toArray();

    if (!candidates.length){
      const wrap = document.createElement('div');
      wrap.style.borderTop='1px solid var(--border)'; wrap.style.padding='10px 0';
      wrap.innerHTML = `<div><strong>${item.name}</strong> &nbsp;<span class="muted2">CSV set: ${item.setCode || '(none)'} ${item.setName ? '— '+item.setName : ''}</span> &nbsp;•&nbsp; Qty: ${item.qty} &nbsp;•&nbsp; <span class="muted2">Row ${item.row}</span></div>
                        <div class="muted small" style="margin-top:6px">Card not recognized in local DB (or wrong name).</div>`;
      addManualCorrectionRow(wrap, item);
      els.resolveList.appendChild(wrap);
      continue;
    }
    const bySet = new Map();
    for (const c of candidates){
      const key = (c.set||'').toUpperCase();
      if (!bySet.has(key)) bySet.set(key, {set:key, set_name:c.set_name || '', any: c});
    }
    if (bySet.has('PLST')){
      const v = bySet.get('PLST');
      await resolveOneUnmatched(item, v.any.id, v.set, v.set_name);
      continue;
    }
    const wrap = document.createElement('div');
    wrap.style.borderTop='1px solid var(--border)'; wrap.style.padding='10px 0';
    const title = document.createElement('div');
    title.innerHTML = `<strong>${item.name}</strong> &nbsp;<span class="muted2">CSV set: ${item.setCode || '(none)'} ${item.setName ? '— '+item.setName : ''}</span> &nbsp;•&nbsp; Qty: ${item.qty} &nbsp;•&nbsp; <span class="muted2">Row ${item.row}</span>`;
    wrap.appendChild(title);
    const row = document.createElement('div');
    row.style.marginTop='8px'; row.className='row';
    const prompt = document.createElement('div');
    prompt.className='muted small'; prompt.textContent='Pick a set:';
    row.appendChild(prompt);
    for (const v of bySet.values()){
      const btn = document.createElement('button');
      btn.className='btn';
      btn.textContent = `${v.set} — ${v.set_name || ''}`;
      btn.addEventListener('click', async () => {
        await resolveOneUnmatched(item, v.any.id, v.set, v.set_name);
        wrap.remove();
      });
      row.appendChild(btn);
    }
    wrap.appendChild(row);
    addManualCorrectionRow(wrap, item);
    els.resolveList.appendChild(wrap);
  }
}
function addManualCorrectionRow(wrap, item){
  const row = document.createElement('div');
  row.className = 'row';
  row.style.marginTop = '8px';

  // keep a small notification, no input / try button
  const message = document.createElement('div');
  message.className = 'inline-msg';
  message.innerHTML =
    `<span class="err">Unmatched.</span>
     <span class="muted small">We couldn’t find this card in your local DB.
     If set options appear above, select one; otherwise update your database or
     verify the name, then re-import.</span>`;
  row.appendChild(message);

  const spacer = document.createElement('div');
  spacer.className = 'grow';
  row.appendChild(spacer);

  // keep the Clear button
  const clearBtn = document.createElement('button');
  clearBtn.className = 'btn ghost';
  clearBtn.textContent = 'Clear';
  clearBtn.addEventListener('click', () => {
    item.resolved = true;
    updateResolveStats();
    wrap.remove();
  });
  row.appendChild(clearBtn);

  wrap.appendChild(row);
}

async function resolveOneUnmatched(item, chosenId){ const cur = await db.collection.get(chosenId) || { id:chosenId, qty:0 }; cur.qty += (item.qty||0); await db.collection.put(cur); item.resolved=true; updateResolveStats(); await refreshStats(); search(); }
function updateResolveStats(){ const remaining = __unmatchedRows.filter(x=>!x.resolved).length; els.resolveStats.textContent = `${remaining} unresolved`; if (!remaining){ setTimeout(()=>{ els.resolveBox.style.display='none'; els.resolveList.innerHTML=''; }, 200); } }

/* -------------------- CSV import (additive) -------------------- */
els.importCSV.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;

  els.csvBox.style.display = '';
  els.csvProgress.value = 0;
  els.csvNote.textContent = `Reading ${file.name}…`;

  try{
    const raw = await file.text();

    // NEW: peel first 1–2 lines if needed and (optionally) provide a known header
    const { csvText, header: externalHeader } = peelCsvHeader(raw);

    const rows = parseCSV(csvText);
    if (!rows.length){ els.csvNote.textContent='No rows found.'; e.target.value=''; return; }

    // Determine header + data rows
    let headerRaw, dataRows;
    if (externalHeader) {
      headerRaw = externalHeader;      // we skipped the header line physically
      dataRows = rows;                 // all rows are data
    } else {
      headerRaw = rows[0];             // first parsed row is the header
      dataRows = rows.slice(1);        // the rest are data
    }

    // Normalize header and build index helper
    const header = headerRaw.map(h => (h||'').toString().trim().toLowerCase().replace(/[^a-z0-9]/g,''));
    const col = (name)=> header.indexOf(name.toLowerCase().replace(/[^a-z0-9]/g,''));

    const iName    = col('cardname');
    const iQty     = col('quantity');
    const iSetCode = col('setcode');
    const iSetName = col('setname');
    // optional: const iDate = col('datebought');

    if (iName===-1 || iQty===-1){
      alert('CSV must include at least Card Name and Quantity columns.');
      e.target.value=''; return;
    }

    const strict = !!els.csvStrict.checked;

    // ——— proceed exactly as before, but iterate dataRows ———
    const increments = {};
    const unmatched = [];
    const totalRows = dataRows.length;
    let processed = 0;

    for (const row of dataRows){
      if (!row || !row.length){ processed++; continue; }

      const name    = (row[iName]||'').trim();
      const qty     = parseInt((row[iQty]||'0').trim(), 10) || 0;
      const setCode = iSetCode>=0 ? (row[iSetCode]||'').trim() : '';
      const setName = iSetName>=0 ? (row[iSetName]||'').trim() : '';

      if (!name || qty<=0){ processed++; continue; }

      const nameLC = name.toLowerCase();
      let candidates = await db.cards.where('name_lc').equals(nameLC).toArray();
      if (!candidates.length) candidates = await db.cards.where('name_lc').startsWith(nameLC).toArray();

      let card = null;
      if (candidates.length) card = selectCardByNameAndSet(candidates, setCode, setName, strict);
      if (!card) unmatched.push({ row: processed+2, name, setCode, setName, qty }); // +2 to reflect original file line numbers roughly
      else increments[card.id] = (increments[card.id]||0) + qty;

      processed++;
      if (processed % 50 === 0 || processed === totalRows){
        els.csvProgress.value = Math.round((processed/Math.max(1,totalRows))*100);
        els.csvNote.textContent = `Matched ${Object.keys(increments).length} unique; ${unmatched.length} unmatched…`;
        await sleep(0);
      }
    }

    // commit + wrap-up (unchanged)
    const ids = Object.keys(increments);
    await db.transaction('rw', db.collection, async () => {
      for (const id of ids){
        const cur = await db.collection.get(id) || { id, qty: 0 };
        cur.qty += increments[id];
        await db.collection.put(cur);
      }
    });

    els.csvProgress.value = 100;
    const totalAdded = Object.values(increments).reduce((a,b)=>a+b,0);
    els.csvNote.textContent = `Imported ${ids.length} unique; added ${totalAdded} total. Unmatched: ${unmatched.length}.`;
    await refreshStats();
    els.status.textContent = 'Added cards to collection.';
    search();

    if (unmatched.length){ renderResolveUnmatched(unmatched); }
    else { els.resolveBox.style.display='none'; els.resolveList.innerHTML=''; }

    hideStatusBars();
  }catch(err){
    console.error(err);
    alert('Failed to import CSV.');
  }

  e.target.value='';
});

els.importTXT.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;

  els.csvBox.style.display = '';          // reuse the little progress UI
  els.csvProgress.value = 0;
  els.csvNote.textContent = `Reading ${file.name}…`;

  try{
    const text = await file.text();
    const rows = parseScannerTXT(text);

    if (!rows.length){
      els.csvNote.textContent = 'No recognizable rows found in TXT.';
      e.target.value=''; return;
      hideStatusBars();
    }

    // Build increments & unmatched, mirroring the CSV logic
    const increments = {};
    const unmatched  = [];
    const totalRows  = rows.length;
    let processed = 0;

    for (const item of rows){
      const name = item.name;
      const qty  = item.qty || 0;
      const setName = item.setName || '';
      if (!name || qty <= 0){ processed++; continue; }

      const nameLC = name.toLowerCase();

      // Try exact by name, then prefix
      let candidates = await db.cards.where('name_lc').equals(nameLC).toArray();
      if (!candidates.length){
        candidates = await db.cards.where('name_lc').startsWith(nameLC).toArray();
      }

      // Try pick by setName if possible, else just first
      let card = null;
      if (candidates.length){
        if (setName){
          const sn = setName.toLowerCase();
          card = candidates.find(c => (c.set_name||'').toLowerCase() === sn) || null;
        }
        if (!card) card = candidates[0] || null;
      }

      if (!card){
        unmatched.push({ row:item.row, name, setCode:'', setName, qty });
      } else {
        increments[card.id] = (increments[card.id] || 0) + qty;
      }

      processed++;
      if (processed % 50 === 0 || processed === totalRows){
        els.csvProgress.value = Math.round((processed/Math.max(1,totalRows))*100);
        els.csvNote.textContent = `Matched ${Object.keys(increments).length} unique; ${unmatched.length} unmatched…`;
        await sleep(0);
      }
    }

    // Write to collection
    const ids = Object.keys(increments);
    await db.transaction('rw', db.collection, async () => {
      for (const id of ids){
        const cur = await db.collection.get(id) || { id, qty: 0 };
        cur.qty += increments[id];
        await db.collection.put(cur);
      }
    });

    els.csvProgress.value = 100;
    const totalAdded = Object.values(increments).reduce((a,b)=>a+b,0);
    els.csvNote.textContent = `TXT add: ${ids.length} unique; +${totalAdded} total. Unmatched: ${unmatched.length}.`;
    await refreshStats();
    els.status.textContent = 'Added cards to collection.';
    search();

    if (unmatched.length){ renderResolveUnmatched(unmatched); }
    else { els.resolveBox.style.display='none'; els.resolveList.innerHTML=''; }
    hideStatusBars();
  }catch(err){
    console.error(err);
    alert('Failed to import TXT.');
  }

  e.target.value='';
});


/* -------------------- Clear actions -------------------- */
els.btnClearDB.addEventListener('click', async () => {
  if (!confirm('Delete ALL cards from local DB? This does NOT remove your collection.')) return;
  await db.cards.clear(); await refreshStats(); els.results.innerHTML=''; els.status.textContent='Cleared DB.';
});
els.btnClearCollection.addEventListener('click', async () => {
  if (!confirm('Clear your collection quantities?')) return;
  await db.collection.clear(); await refreshStats(); document.querySelectorAll('.qty-in').forEach(el=>el.value=0); els.status.textContent='Cleared collection.';
});
refreshStats();
</script>
</body>
</html>
